# A0145732H
###### Add.java
``` java
/**
 * Add command to handle adding a task to the task list.
 * @author Katherine Coronado
 *
 */
public class Add extends Command implements Undoable {
	private static final String SUCCESS_ADD = "Added %s.";
	private static final String SUCCESS_ADD_UNDO = "\"%s\" was removed.";
	private static final String ERROR_TASK_ALREADY_EXISTS = "The task which you are trying to add already exists.";
	
	
	private Task task;
	private boolean wasExecuted;
	
	public Add(Task task) {
		this.task = task;
		this.wasExecuted = false;
	}
	
	@Override
	/**
	 * Add a task to the task list.
	 */
	public void execute() throws Exception {
		// validateDates() will throw an exception if the dates are not valid
		logic.validateDates(task.getStartDateTime(), task.getEndDateTime());
		
		if (logic.doesTaskExist(task)) {
			log.log(Level.INFO, "aborting, the task to be added already exists\n");
			throw new Exception(ERROR_TASK_ALREADY_EXISTS);
		}
		
		storageManager.writeTask(task);
		wasExecuted = true;
	}

	@Override
	/**
	 * Remove the task added by this instance of Add.
	 */
	public void undo() throws Exception {
		storageManager.removeTask(task);
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return String.format(SUCCESS_ADD, Ui.getPrintableTaskString(task));
	}

	@Override
	public String getUndoMessage() {
		assert(wasExecuted);
		return String.format(SUCCESS_ADD_UNDO, task.getName());
	}

```
###### Clear.java
``` java
	@Override
	public void undo() throws Exception {
		assert(wasExecuted);
		for (Task task : erasedTaskList) {
			storageManager.writeTask(task);
		}
	}

```
###### Command.java
``` java
/**
 * Command is a class that contains all the required information for Logic to
 * execute it. It is created by CommandParser's parse method.
 */
public abstract class Command {
	protected static StorageManager storageManager = null;
	protected static Logic logic = null;
	protected static final Logger log = Logger.getLogger(Ui.LOG_NAME);	
	
	public abstract void execute() throws Exception;
	public abstract String getSuccessMessage();
	
	public static void setLogic(Logic logicInstance) {
		assert(logicInstance != null);
		logic = logicInstance;
	}
	
```
###### CommandParser.java
``` java
  private static Command initListCommand(ArrayList<String> args) throws Exception {
		if (args.size() == 0) {
			return new List();
		} else {
  		// parse the flags and keywords
  		EnumSet<List.LIST_FLAGS> listFlags = EnumSet.noneOf(List.LIST_FLAGS.class);
  		String[] keywords = null;
  		boolean isAllMarked = false;
  		for (int i = 0; i < args.size(); i++) {
  			String flag = args.get(i);
  			switch (flag) {
  				case "unscheduled" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.UNSCHEDULED);
  					}
  					break;
  					
  				case "deadlines" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.DEADLINE);
  					}
  					break;
  					
  				case "events" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.EVENT);
  					}
  					break;
  					
  				case "done" :
  					// fallthrough
  					
  				case "completed" :
  					// fallthrough
  					
  				case "finished" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.COMPLETED);
  					}
  					break;
  					
  				case "uncompleted" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.UNCOMPLETED);
  					}
  					break;
  					
  				case "today" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.TODAY);
  					}
  					break;  					
  					
  				case "tomorrow" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.TOMORROW);
  					}
  					break;  					
  					
  				default :
  					// if there are quotation marks, it is a keywords string
  					if (flag.startsWith("\"")) {
  						flag = flag.replace("\"", "");
  						keywords = flag.split(" ");
  					} else {
  						throw new Exception("\"" + flag + "\" is not a recognized keyword");
  					}
  					break;
				}
  		}
  		if (keywords == null) {
  			return new List(listFlags);
  		} else {
  			return new List(listFlags, keywords);
  		}
  	}
  }
    
```
###### Exit.java
``` java
/**
 * Exit command to handle closing TaskBuddy cleanly. 
 * @author Katherine Coronado
 *
 */
public class Exit extends Command {
	private boolean wasExecuted;
	
	public Exit() {
		this.wasExecuted = false;
	}
	
	@Override
	/**
	 * Calls the necessary methods to exit TaskBuddy cleanly
	 */
	public void execute() throws Exception {
		Ui.indicateExit();
		wasExecuted = true;
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return "Goodbye\n";
	}

}
```
###### List.java
``` java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;

/**
 * List command used for listing all tasks or for performing a search on the task list
 * @author Katherine Coronado
 *
 */
public class List extends Command {	
	private String[] keywords;
	private ArrayList<Task> taskList;
	EnumSet<LIST_FLAGS> flags;
	private boolean wasExecuted;
	
	public enum LIST_FLAGS {
		UNSCHEDULED, DEADLINE, EVENT, COMPLETED, UNCOMPLETED, TODAY, TOMORROW;
	}
	public static final EnumSet<LIST_FLAGS> LIST_FLAGS_ENUM_SET = EnumSet.allOf(LIST_FLAGS.class);
	
	/** 
	 * Constructs a List object to list all tasks
	 */
	public List() {
		this.keywords = null;
		this.taskList = null;
		this.flags = null;
		this.wasExecuted = false;
	}
	
	public List(EnumSet<LIST_FLAGS> listFlags) {
		this();
		this.flags = listFlags;
	}

	public List(EnumSet<LIST_FLAGS> listFlags, String[] keywords) {
		this(listFlags);
		this.keywords = keywords;
	}

	@Override
	/**
	 * This method handles whether to filter the task list or get the uncompleted tasks list. 
	 */
	public void execute() throws Exception {
		ArrayList<Task> tasks = storageManager.readAllTasks();
		if (keywords != null) {
			tasks = logic.searchTasks(keywords);
		}
		if (flags != null) {
			tasks = getFlaggedTasks(tasks);
		}
		taskList = tasks;
		wasExecuted = true;
	}

	private ArrayList<Task> getFlaggedTasks(ArrayList<Task> flaggedTasks) {
		// keep refining the task list based on which flags are marked
		if (flags.contains(LIST_FLAGS.COMPLETED)) {
			flaggedTasks = logic.getCompletedTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.UNCOMPLETED)) {
			flaggedTasks = logic.getUncompletedTasks(flaggedTasks);
		}		
		if (flags.contains(LIST_FLAGS.UNSCHEDULED)) {
			flaggedTasks = logic.getUnscheduledTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.DEADLINE)) {
			flaggedTasks = logic.getDeadlines(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.EVENT)) {
			flaggedTasks = logic.getEvents(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.TODAY)) {
			flaggedTasks = logic.getTodaysTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.TOMORROW)) {
			flaggedTasks = logic.getTomorrowsTasks(flaggedTasks);
		}
		return flaggedTasks;
	}

	@Override
	/**
	 * Prints out all the tasks in the taskList
	 */
	public String getSuccessMessage() {
		assert(wasExecuted);
		return Ui.createTaskListDisplay(taskList);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		List other = (List)obj;	
		boolean isExecutedEqual = (this.wasExecuted == other.wasExecuted);
		boolean areKeywordsEqual = Arrays.equals(this.keywords, other.keywords);
		boolean areTaskListsEqual = this.taskList.equals(other.taskList);
		boolean areFlagsEqual = this.flags.equals(other.flags);
		return (isExecutedEqual && areKeywordsEqual && areTaskListsEqual && areFlagsEqual);
	}
	
	/**
	 * This method returns the tasks that contain the keywords.
	 * 
	 * @return	ArrayList of tasks generated by the execute() method
	 */
	public ArrayList<Task> getTaskList() {
		// assert that this instance of List has been executed before returning
		assert(taskList != null);
		return this.taskList;
	}
}
```
###### Logic.java
``` java
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Stack;

/*
 *The logic class will process user input from UI, and return the result of the processing to UI.
 *For example, UI gets info about successful execution   of a command. 
 *Errors encountered during input parsing or execution will be propagated by exceptions
 */

public class Logic {
	// error messages for when the date configuration of tasks is invalid
	private static final String ERROR_DATE_INVALID_EVENT = "You cannot have an end time earlier than the start time.";
	
	// constants to define the size of the default task view and the number of each type of task
	public static final int DEFAULT_VIEW_NUM_UNSCHEDULED = 3;
	public static final int DEFAULT_VIEW_NUM_DEADLINES = 6;
	public static final int DEFAULT_VIEW_NUM_EVENTS = 6;
	public static final int DEFAULT_VIEW_MAX_TASKS = 15;
	
	// class variables to keep track of command history for the undo command
	private static Stack<Undoable> undoableHistory = new Stack<Undoable>();
	private static Command lastExecutedCommand = null;
	
	// single instances
	protected static StorageManager storageManager = null;
	protected static Logic commandLogic = null;
	
	public Logic() {
	}
	
```
###### Logic.java
``` java
	public Command processUserInput(String userInput) throws Exception {
		Command command;
		try {
			command = CommandParser.getCommandFromInput(userInput);
		} catch (Exception e) {
			lastExecutedCommand = null;
			throw new Exception(e.getMessage());			
		}
		
		// this may throw an Exception depending on the command
		try {
			command.execute();
		} catch (Exception e) {
			lastExecutedCommand = null;
			throw new Exception(e.getMessage());
		}
		
		// update command history depending on the command
		lastExecutedCommand = command;
		if (command.getClass() == Undo.class && !undoableHistory.isEmpty()) {
			undoableHistory.pop();
		} else if (Undoable.class.isAssignableFrom(command.getClass())) {
			undoableHistory.push((Undoable)command);
		}
		return command;
	}
	
	/**
	 * This method searches the task list for tasks containing all of the given keywords
	 * 
	 * @param keywords	the array of keywords to search for in the task names
	 * @return			an ArrayList of the tasks containing all of the keywords
	 * 					The ArrayList will be empty if no tasks were found.
	 */
	public ArrayList<Task> searchTasks(String[] keywords) {
		assert(keywords != null);
		
		ArrayList<Task> taskList = storageManager.readAllTasks();
		ArrayList<Task> foundTasks = new ArrayList<Task>();		
		for (int i = 0; i < taskList.size(); i++) {
			int keywordIndex = 0;
			Task currentTask = taskList.get(i);
			
			// check if currentTask contains all of the keywords before adding to foundTasks
			while (keywordIndex < keywords.length) {
				String taskName = currentTask.getName().toLowerCase();
				if (!taskName.contains(keywords[keywordIndex++].toLowerCase())) {
					break;
				}
				if (keywordIndex == keywords.length) {
					foundTasks.add(currentTask);
				}
			}
		}
		return foundTasks;
	}

	/**
	 * This method searches for all of the tasks marked as done in a given task list
	 * 
	 * @param taskList	the ArrayList to search through to get the completed tasks
	 * @return			an ArrayList of the completed tasks
	 */
	public ArrayList<Task> getCompletedTasks(ArrayList<Task> taskList) {
		ArrayList<Task> completed = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.isDone()) {
				completed.add(task);
			}
		}
		return completed;	
	}

	/**
	 * This method searches for all of the tasks that are not marked as done by the user.
	 * 
	 * @return	an ArrayList of tasks marked as not done
	 */
	public ArrayList<Task> getUncompletedTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getUncompletedTasks(taskList);
	}

	/**
	 * This methods searches for all of the tasks that are not marked as done in a given task list
	 * @param taskList	the ArrayList to search through to get the uncompleted tasks
	 * @return			an ArrayList of the uncompleted tasks
	 */
	public ArrayList<Task> getUncompletedTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> uncompleted = new ArrayList<Task>();
		for (Task task : taskList) {
			if (!task.isDone()) {
				uncompleted.add(task);
			}
		}
		return uncompleted;
	}
	
	/**
	 * This method searches for all of the unscheduled tasks in a specified task list
	 * 
	 * @param taskList	the specified task list to filter for unscheduled tasks
	 * @return			an ArrayList of the found unscheduled tasks
	 */
	public ArrayList<Task> getUnscheduledTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> unscheduled = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.getStartDateTime() == null && task.getEndDateTime() == null) {
				unscheduled.add(task);
			}
		}
		return unscheduled;	
	}
	
	/**
	 * This method searches for all of the deadlines in a specified task list
	 * 
	 * @param taskList	the specified task list to filter for deadlines
	 * @return			an ArrayList of the found deadlines
	 */
	public ArrayList<Task> getDeadlines(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> deadlines = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.getStartDateTime() == null && task.getEndDateTime() != null) {
				deadlines.add(task);
			}
		}
		return deadlines;	
	}
	
	/**
	 * This method searches for all of the events in a specified task list
	 * 
	 * @param taskList	the specified task list to filter for events
	 * @return			an ArrayList of the found events
	 */
	public ArrayList<Task> getEvents(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> events = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.getStartDateTime() != null && task.getEndDateTime() != null) {
				events.add(task);
			}
		}
		return events;	
	}
	
	/**
	 * This method searches for any events or deadlines happening today from a specified task list
	 * 
	 * @param taskList	the specified task list to filter for today's tasks
	 * @return			an ArrayList of today's tasks
	 */
	public ArrayList<Task> getTodaysTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		LocalDate today = LocalDate.now();
		ArrayList<Task> todaysTasks = new ArrayList<Task>();
		for (Task task : taskList) {
			LocalDateTime start = task.getStartDateTime();
			LocalDateTime end = task.getEndDateTime();
			if (start != null && end != null) {
				if (start.toLocalDate().compareTo(today) == 0 
						|| end.toLocalDate().compareTo(today) == 0) {
					todaysTasks.add(task);
				}
			} else if (end != null) {
				if (end.toLocalDate().compareTo(today) == 0) {
					todaysTasks.add(task);
				}
			}
		}
		return todaysTasks;
	}
	
	/**
	 * This method searches for any events or deadlines happening tomorrow from a specified task list
	 * 
	 * @param taskList	the specified task list to filter for tomorrow's tasks
	 * @return			an ArrayList of tomorrow's tasks
	 */
	public ArrayList<Task> getTomorrowsTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		LocalDate tomorrow = LocalDate.now().plusDays(1);
		ArrayList<Task> tomorrowsTasks = new ArrayList<Task>();
		
		for (Task task : taskList) {
			LocalDateTime start = task.getStartDateTime();
			LocalDateTime end = task.getEndDateTime();
			if (start != null && end != null) {
				if (start.toLocalDate().compareTo(tomorrow) == 0 
						|| end.toLocalDate().compareTo(tomorrow) == 0) {
					tomorrowsTasks.add(task);
				}
			} else if (end != null) {
				if (end.toLocalDate().compareTo(tomorrow) == 0) {
					tomorrowsTasks.add(task);
				}
			}
		}
		return tomorrowsTasks;
	}
	
	/**
	 * Validate whether the event dates are valid (start has to be before end)
	 * @param start			the start date and time of the event
	 * @param end			the end date and time of the event
	 * @throws Exception	if the start is not before the end
	 */
	public void validateDates(LocalDateTime start, LocalDateTime end) throws Exception {
		if (start == null) {
			// dates are always valid for unscheduled tasks and deadlines
			return;
		}
		boolean areDatesValid = end.compareTo(start) > 0;
		if (!areDatesValid) {
			throw new Exception(ERROR_DATE_INVALID_EVENT);
		}
	}
	
	/**
	 * Get the last undoable command executed by the program.
	 * 
	 * @return	the last Undoable command stored in the command history
	 * @throws EmptyStackException	if there are no more commands in the stack
	 */
	public Undoable getLastUndoable() throws EmptyStackException {
		return undoableHistory.peek();
	}

	/**
	 * Generate the default task list for the default view.
	 * @return
	 */
	private ArrayList<Task> getDefaultTaskList() {
		ArrayList<Task> defaultTasks = new ArrayList<Task>();
		ArrayList<Task> uncompleted = getUncompletedTasks();
		ArrayList<Task> uncompletedUnscheduled = getUnscheduledTasks(uncompleted);
		ArrayList<Task> uncompletedDeadlines = getDeadlines(uncompleted);
		ArrayList<Task> uncompletedEvents = getEvents(uncompleted);
		
		int numTasks = 0;
		int tasksForView;
		// display up to 15 tasks
		if (uncompleted.size() < DEFAULT_VIEW_MAX_TASKS) {
			tasksForView = uncompleted.size();
		} else {
			tasksForView = DEFAULT_VIEW_MAX_TASKS;
		}
		// display an even amount of each task type.
		// if there are not enough tasks of a task type, then distribute between the remaining types.
		int eventIndex = 0;
		int deadlineIndex = 0;
		int unscheduledIndex = 0;
		int extraTasks = 0;
		while (numTasks < tasksForView) {
			if (eventIndex < uncompletedEvents.size()) {
				if (eventIndex < DEFAULT_VIEW_NUM_EVENTS) {
					defaultTasks.add(uncompletedEvents.get(eventIndex++));
					numTasks++;				
				} else if (extraTasks > 0) {
					defaultTasks.add(uncompletedEvents.get(eventIndex++));
					numTasks++;				
					extraTasks--;
				}
				if (numTasks == tasksForView) {
					break;
				}
			} else if (eventIndex < DEFAULT_VIEW_NUM_EVENTS) {
				extraTasks++;
				eventIndex++;
			}
			if (deadlineIndex < uncompletedDeadlines.size()) {
				if (deadlineIndex < DEFAULT_VIEW_NUM_DEADLINES) {
					defaultTasks.add(uncompletedDeadlines.get(deadlineIndex++));
					numTasks++;				
				} else if (extraTasks > 0) {
					defaultTasks.add(uncompletedDeadlines.get(deadlineIndex++));
					numTasks++;				
					extraTasks--;
				}
				if (numTasks == tasksForView) {
					break;
				}
			} else if (deadlineIndex < DEFAULT_VIEW_NUM_DEADLINES) {
				extraTasks++;
				deadlineIndex++;
			}
			if (unscheduledIndex < uncompletedUnscheduled.size()) {
				if (unscheduledIndex < DEFAULT_VIEW_NUM_UNSCHEDULED) {
					defaultTasks.add(uncompletedUnscheduled.get(unscheduledIndex++));
					numTasks++;				
				} else if (extraTasks > 0) {
					defaultTasks.add(uncompletedUnscheduled.get(unscheduledIndex++));
					numTasks++;				
					extraTasks--;
				}
				if (numTasks == tasksForView) {
					break;
				}
			}else if (unscheduledIndex < DEFAULT_VIEW_NUM_UNSCHEDULED) {
				extraTasks++;
				unscheduledIndex++;
			}
		}
		
		defaultTasks.sort(null);
		return defaultTasks;
	}

	/**
	 * Get the task list to correspond to subsequent references by index
	 * 
	 * @return	the list of tasks
	 */
	public ArrayList<Task> updateCurrentTaskList() {
		if (lastExecutedCommand != null && lastExecutedCommand.getClass() == List.class) {
			List command = (List)lastExecutedCommand;
			return command.getTaskList();
		} else {
			return getDefaultTaskList();
		}
	}
	
	/**
	 * Generate the default view depending on whether a list was just shown or not
	 * 
	 * @return	a string representation of the default view to show
	 */
	public String getDefaultView() {
		if (lastExecutedCommand != null && lastExecutedCommand.getClass() == List.class) {
			return "";
		} else {
			ArrayList<Task> taskList = Ui.getCurrentTaskList();
			return Ui.createTaskListDisplay(taskList) + "\n\n";
		}
	}

```
###### LogicTest.java
``` java
import java.time.LocalDateTime;
import java.util.ArrayList;

import org.junit.Test;

public class LogicTest {
	private Logic logic = new Logic();
	@Test
	public void testSearchTasks() throws Exception {
		StorageManagerStub sm = new StorageManagerStub();
		Logic commandLogic = new Logic();
		logic.init(sm, commandLogic);
				
		Task apple = new Task("apple", false);
		Task banana = new Task("banana", false);
		Task baby = new Task("baby", false);
		Task appleBanana = new Task("apple banana", false);
		
		sm.writeTask(apple);
		sm.writeTask(banana);
		sm.writeTask(baby);
		sm.writeTask(appleBanana);
		
		ArrayList<Task> expected = new ArrayList<Task>();
		ArrayList<Task> actual;
		
		// test searching "b"
		// equivalence partition for searching for one keyword
		actual = logic.searchTasks(new String[] {"b"});
		expected.add(banana);
		expected.add(baby);
		expected.add(appleBanana);
		assert(actual.equals(expected));
		
		// test searching "apple b"
		// equivalence partition for searching with more than one keyword
		actual = logic.searchTasks(new String[] {"apple", "b"});
		expected.clear();
		expected.add(appleBanana);
		assert(actual.equals(expected));
		
		// test searching "c"
		// equivalence partition for searching and not finding anything
		actual = logic.searchTasks(new String[] {"c"});
		expected.clear();
		assert(actual.equals(expected));
	}
	
	@Test
	public void testGetTasksMethods() throws Exception {
		StorageManagerStub sm = new StorageManagerStub();
		Logic commandLogic = new Logic();
		logic.init(sm, commandLogic);
		
		Task t1 = new Task("1", true);
		Task t2 = new Task("2", false);
		Task t3 = new Task("3", LocalDateTime.now(), true);
		Task t4 = new Task("4", LocalDateTime.now().plusDays(1), false);
		Task t5 = new Task("5", LocalDateTime.now().plusDays(2), false);
		Task t6 = new Task("6", LocalDateTime.now(), LocalDateTime.now().plusDays(1), true);
		Task t7 = new Task("7", LocalDateTime.now().plusDays(1), LocalDateTime.now().plusDays(2), false);
		Task t8 = new Task("8", LocalDateTime.now().plusDays(2), LocalDateTime.now().plusDays(3), false);
		
		sm.writeTask(t1);
		sm.writeTask(t2);
		sm.writeTask(t3);
		sm.writeTask(t4);
		sm.writeTask(t5);
		sm.writeTask(t6);
		sm.writeTask(t7);
		sm.writeTask(t8);
		
		// test getCompletedTasks()
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(t1);
		expected.add(t3);
		expected.add(t6);
		
		ArrayList<Task> actual = logic.getCompletedTasks(sm.readAllTasks());
		assert(actual.equals(expected));
		expected.clear();
		
		// test getUncompletedTasks()
		expected.add(t2);
		expected.add(t4);
		expected.add(t5);
		expected.add(t7);
		expected.add(t8);
		
		actual = logic.getUncompletedTasks();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getUnscheduledTasks()
		expected.add(t1);
		expected.add(t2);
		
		actual = logic.getUnscheduledTasks(sm.readAllTasks());
		assert(actual.equals(expected));
		expected.clear();
		
		// test getDeadlineTasks()
		expected.add(t3);
		expected.add(t4);
		expected.add(t5);
		
		actual = logic.getDeadlines(sm.readAllTasks());
		assert(actual.equals(expected));
		expected.clear();
		
		// test getEvents()
		expected.add(t6);
		expected.add(t7);
		expected.add(t8);
		
		actual = logic.getEvents(sm.readAllTasks());
		assert(actual.equals(expected));
		expected.clear();
		
		// test getTodaysTasks()
		expected.add(t3);
		expected.add(t4);
		
		actual = logic.getTodaysTasks(sm.readAllTasks());
		assert(actual.equals(expected));
		expected.clear();
		
		// test getTomorrowsTasks()
		expected.add(t4);
		expected.add(t6);
		expected.add(t7);
		
		actual = logic.getTomorrowsTasks(sm.readAllTasks());
		assert(actual.equals(expected));
		expected.clear();
	}
	
	@Test
	public void testValidateDates() throws Exception {
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime later = now.plusSeconds(1);
		
		// now is before later - should be valid
		
			logic.validateDates(now, later);

		// both dates are equal - should throw exception
		Exception exception = null;
		try {
			logic.validateDates(now, now);
		} catch (Exception e) {
			exception = e;
		}
		assert(exception != null);
		
		// later is before now - should throw exception
		exception = null;
		try {
			logic.validateDates(later, now);
		} catch (Exception e) {
			exception = e;
		}
		assert(exception != null);
	}
	
	@Test
	public void testUpdateCurrentTaskList() throws Exception {
		StorageManagerStub sm = new StorageManagerStub();
		Logic commandLogic = new Logic();
		logic.init(sm, commandLogic);
		ArrayList<Task> unscheduled = new ArrayList<Task>();
		ArrayList<Task> deadlines = new ArrayList<Task>();
		ArrayList<Task> events = new ArrayList<Task>();
		ArrayList<Task> actual;
		
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			unscheduled.add(new Task("unscheduled " + i, false));
			deadlines.add(new Task("deadline " + i, LocalDateTime.now(), false));
			events.add(new Task("event " + i, LocalDateTime.now(), LocalDateTime.now().plusDays(1), false));
		}
		
		/* test that default display shows the right number of each 
			task type when there are enough of each type */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(unscheduled.get(i));
			sm.writeTask(deadlines.get(i));
			sm.writeTask(events.get(i));
		}
		actual = logic.updateCurrentTaskList();
		// these get methods are tested in the test suite - they are assumed to work here
		assert(logic.getUnscheduledTasks(actual).size() == Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(logic.getDeadlines(actual).size() == Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(logic.getEvents(actual).size() == Logic.DEFAULT_VIEW_NUM_EVENTS);
		sm.clearTasks();
		
		/* test that the default number of tasks is displayed when 
			there is only one type of task */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(events.get(i));
		}
		actual = logic.updateCurrentTaskList();
		assert(actual.size() == Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
		/* test that the correct number of tasks is displayed when
		 * there are only two types of tasks 
		 */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(unscheduled.get(i));
			sm.writeTask(deadlines.get(i));
		}
		actual = logic.updateCurrentTaskList();
		assert(logic.getUnscheduledTasks(sm.readAllTasks()).size() > Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(logic.getDeadlines(sm.readAllTasks()).size() > Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(actual.size() == Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
		/* test that the correct number of tasks is displayed when
		 * there are not enough of one type of task, but enough of 
		 * the other two to compensate. 
		 */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(unscheduled.get(i));
			sm.writeTask(deadlines.get(i));
		}
		sm.writeTask(events.get(0));
		actual = logic.updateCurrentTaskList();
		assert(logic.getUnscheduledTasks(sm.readAllTasks()).size() > Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(logic.getDeadlines(sm.readAllTasks()).size() > Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(logic.getEvents(sm.readAllTasks()).size() < Logic.DEFAULT_VIEW_NUM_EVENTS);
		assert(actual.size() == Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
		/* test that the correct number of tasks is displayed when
		 * there are not enough tasks
		 */
		sm.writeTask(unscheduled.get(0));
		sm.writeTask(deadlines.get(0));
		sm.writeTask(events.get(0));
		actual = logic.updateCurrentTaskList();
		assert(logic.getUnscheduledTasks(sm.readAllTasks()).size() < Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(logic.getDeadlines(sm.readAllTasks()).size() < Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(logic.getEvents(sm.readAllTasks()).size() < Logic.DEFAULT_VIEW_NUM_EVENTS);
		assert(actual.size() < Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
	}
}
```
###### Remove.java
``` java
import java.util.ArrayList;
import java.util.logging.Level;

/**
 * Remove command to handle removing a task from the task list.
 * @author Katherine Coronado
 *
 */
public class Remove extends Command implements Undoable {
	private static final String SUCCESS_REMOVE = "\"%s\" was removed.";
	private static final String SUCCESS_REMOVE_UNDO = "\"%s\" was re-added.";
	private static final String ERROR_INDEX_INVALID = "The task number specified is not valid.";
	
	private Task task;
	private int index;
	private boolean isExecuted;
	
	public Remove(int taskNumber) {
		this.index = taskNumber - 1;
		this.isExecuted = false;
		this.task = null;
	}
	
	@Override
	/**
	 * Remove the task from the task list.
	 */
	public void execute() throws Exception {
		ArrayList<Task> taskList = Ui.getCurrentTaskList();
		if (index >= 0 && index < taskList.size()) {
			task = taskList.get(index);
			storageManager.removeTask(task);
		} else {
			log.log(Level.INFO, "aborting, the task number entered is invalid\n");
			throw new Exception(ERROR_INDEX_INVALID);
		}
		isExecuted = true;
	}

	@Override
	/**
	 * Re-add the task that was removed by this instance of Remove.
	 */
	public void undo() throws Exception {
		storageManager.writeTask(task);
	}

	@Override
	public String getSuccessMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_REMOVE, task.getName());
	}

```
###### StorageManager.java
``` java
	/**
	 * This method reads all task existing in the Storage
	 * 
	 * @throws Exception	if the task was unable to be written
	 */
	public ArrayList<Task> readAllTasks() {
		ArrayList<Task> taskArrayList = new ArrayList<Task>();

		taskArrayList.addAll(Arrays.asList(TASK_LIST));
		taskArrayList.sort(null);

		log.log(Level.INFO, "Returning all the tasks in a sorted order.\n");
		return taskArrayList;
	}

```
###### StorageManager.java
``` java
	/**
	 * This method removes a given task from the Storage
	 * 
	 * @param task
	 * @throws Exception	if the task was unable to be removed
	 */
	public void removeTask(Task task) throws Exception {
		assert(file.exists());
		
		boolean isRemoved = false;
		try {
			ArrayList<Task> taskListTransition;
			Task[] taskListToUpdate;
			
			taskListTransition = new ArrayList<Task> (Arrays.asList(TASK_LIST));
			
			isRemoved = taskListTransition.remove(task);
			
			taskListToUpdate = taskListTransition.toArray(new Task[taskListTransition.size()]);
			
			TASK_LIST = new Task[taskListToUpdate.length];
			TASK_LIST = taskListToUpdate;
			
			closeWriter();
			setWriterWithoutAppend();
			
			gson.toJson(taskListToUpdate, bufferedWriter);
			bufferedWriter.flush();
			
		} catch (Exception e) {
			isRemoved = false;
			log.log(Level.WARNING, "Task could not be removed.\n");
			throw new Exception(ERROR_TASK_NOT_REMOVED);
		}
		
		if (!isRemoved) {
			throw new Exception(String.format(ERROR_TASK_NOT_FOUND, task.getName()));
		}
		
		log.log(Level.INFO, "Successfully removed task from task list.\n");
	}

	/**
	 * This method updates a task in the task list with the new task in Storage
	 * 
	 * @param oldTask		the task to search for and update
	 * @param newTask		the updated version of the task to replace the old task
	 * @throws Exception	if there are no tasks or if the old task was not found
	 */
	public void updateTask(Task oldTask, Task newTask) throws Exception {
		assert(file.exists());
		
		if (TASK_LIST.length == 0) {
			throw new Exception(ERROR_EMPTY_TASK_LIST);
		}

		removeTask(oldTask);
		writeTask(newTask);
		
		log.log(Level.INFO, "Successfully updated task from task list.\n");
	}

```
###### Task.java
``` java
	@Override
	/**
	 * Tasks are ordered by events, deadlines, then unscheduled tasks (ascending).
	 * Events are compared to other events first by start date, then by end date, then by name.
	 * Deadlines are compared to other deadlines first by end date, then by name.
	 * Unscheduled tasks are compared to other unscheduled tasks by name.
	 */
	public int compareTo(Task otherTask) {
		if (otherTask == null) {
			throw new NullPointerException();
		}
		if (this.equals(otherTask)) {
			return 0;
		}
		
		LocalDateTime otherStart = otherTask.getStartDateTime();
		LocalDateTime otherEnd = otherTask.getEndDateTime();
		String otherName = otherTask.getName();
		
		// If this is an event:
		if (this.start != null && this.end != null) {
			// if other is not an event: this < other
			if (otherStart == null) {
				return -1;
			} else {
				// sort order: start date, end date, name
				if (!this.start.equals(otherStart)) {
					return (this.start.compareTo(otherStart));
				} else if (!this.end.equals(otherEnd)) {
					return (this.end.compareTo(otherEnd));
				} else {
					return (this.name.compareTo(otherName));
				}
			}
		}
		
		// If this is a deadline task - sorted by end date, then name
		if (this.end != null && this.start == null) {
			if (otherStart != null) {
				// this is a deadline, other is an event --> this > other
				return 1;
			} else if (otherEnd == null) {
				// this is a deadline, other is unscheduled --> this < other
				return -1;
			} else {
				// both this and other are deadlines: sort by end date then by name
				if (!this.end.equals(otherEnd)) {
					return (this.end.compareTo(otherEnd));
				} else {
					return (this.name.compareTo(otherName));
				}
			}
		}
		// 3. unscheduled tasks - sorted by name
		if (this.end == null && this.start == null) {
			if (otherStart != null || otherEnd != null) {
				// this is a unscheduled, other is not unscheduled --> this > other
				return 1;
			} else {
				// both are unscheduled --> sort by name
				return (this.name.compareTo(otherName));
			}
		}
		return 0;
		
	}
}
```
###### Ui.java
``` java
import org.fusesource.jansi.AnsiConsole;
import static org.fusesource.jansi.Ansi.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Scanner;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

/**
 * The UI class handles all user input and output to the screen.
 * It sends the user input to the logic component for processing,
 * and it handles displaying the command feedback and errors to the user. 
 * Exceptions thrown by the logic component to indicate errors are handled by UI. 
 * 
 * @author Katherine Coronado
 *
 */

public class Ui {
	/** text marker to indicate whether a task is completed or not when displaying tasks **/
	public static final String MARKER_UNCOMPLETED = "     ";
	public static final String MARKER_DONE = "DONE ";
	
	/** Jansi tags for color coding strings based on the date **/
	private static final String COLOR_CODE_END_TAG = "|@";
	public static final String COLOR_CODE_FUTURE = "@|CYAN ";
	public static final String COLOR_CODE_TOMORROW = "@|GREEN ";
	public static final String COLOR_CODE_TODAY = "@|YELLOW ";
	public static final String COLOR_CODE_OVERDUE = "@|RED ";
	
	/** messages to be displayed to the user **/
	private static final String MESSAGE_WELCOME = "Welcome to HelloTask!\n\n";
	private static final String MESSAGE_COMMAND_PROMPT = "> ";
	
	/** messages and message formats for tasks in the task list display **/
	private static final String MESSAGE_NO_TASKS = "No tasks to display.";
	public static final String MESSAGE_UNSCHEDULED = "%s%d. %s\n";
	public static final String MESSAGE_DEADLINE = "%s%d. %s\n\tdue %s at %s\n";
	public static final String MESSAGE_EVENT = "%s%d. %s\n\t%s to %s\n";
	public static final String MESSAGE_UNSCHEDULED_HEADER = "\nUnscheduled tasks:\n";
	public static final String MESSAGE_DEADLINE_HEADER = "\nDeadlines:\n";
	public static final String MESSAGE_EVENTS_HEADER = "\nEvents:\n";
	public static final String MESSAGE_DATE = "%s, %d %s";
	public static final String MESSAGE_DATE_YEAR = MESSAGE_DATE + " %d";
	public static final String MESSAGE_TIME = "%d:%02d %s";
	public static final String MESSAGE_DATE_TIME = "%s at %s";
	
	/** message formats for user command feedback **/
	private static final String MESSAGE_FEEDBACK_EVENT = "\"%s\", scheduled from %s to %s";
	private static final String MESSAGE_FEEDBACK_DEADLINE = "\"%s\" due by %s";
	private static final String MESSAGE_FEEDBACK_UNSCHEDULED = "\"%s\"";
	
	/** class variables pertaining to the running of Ui **/
	private static boolean isRunning;
	private static Scanner keyboard;
	private static ArrayList<Task> currentTaskList;
	private static Logic logic;
	
	/** logger variables **/
	static final String LOG_NAME = "HelloTaskLog";
	private static Logger logger = Logger.getLogger(LOG_NAME);
	
	public static void main(String[] args) throws Exception {
		helloTaskInit();
		showToUser(MESSAGE_WELCOME);
		while (isRunning) {
			currentTaskList = logic.updateCurrentTaskList();
			showToUser(logic.getDefaultView());
			showToUser(MESSAGE_COMMAND_PROMPT);
			String userInput = getUserInput();
			executeUserInput(userInput);
		}
		helloTaskClose();
	}

	/** 
	 * This method gets user input from the keyboard
	 * 
	 * @return	the user's input string
	 */
	private static String getUserInput() {
		String userInput = keyboard.nextLine();
		logger.log(Level.INFO, "user entered \"" + userInput + "\"");
		return userInput;
	}

	/**
	 * This method initiates HelloTask by initializing the class variables
	 * @throws Exception 
	 */
	private static void helloTaskInit() throws Exception {
		loggerInit();
		uiInit();
		logicInit();
		logger.log(Level.INFO, "HelloTask initialized successfully\n");
	}

	public static void logicInit() throws Exception {
		logic = new Logic();
		logic.init(new StorageManager(), new Logic());
	}

	public static void loggerInit() {
		try {
			FileHandler handler = new FileHandler(LOG_NAME);
			handler.setFormatter(new SimpleFormatter());
			LogManager.getLogManager().reset();
			logger.addHandler(handler);
			logger.log(Level.INFO, "logger initialized\n");
		} catch (Exception e) {
			/* error opening the log file - just get rid of logging so it won't 
			 * print to the console while the user is running the program */
			LogManager.getLogManager().reset();
		}
	}

	public static void uiInit() {
		AnsiConsole.systemInstall();
		keyboard = new Scanner(System.in);
		isRunning = true;
	}

	/**
	 * This method closes Task Buddy
	 * @throws Exception 
	 */
	private static void helloTaskClose() {
		logger.log(Level.INFO, "closing HelloTask\n");
		try {
			logic.close();
		} catch (Exception e) {
			logger.log(Level.WARNING, "caught exception: " + e.getMessage());
		}
		keyboard.close();
		AnsiConsole.systemUninstall();
		System.exit(0);
	}
	
	/**
	 * This method will handle the user's input to be evaluated and executed
	 * 
	 * @param userInput	the string entered by the user
	 */
	public static void executeUserInput(String userInput) {
		try {
			Command command = logic.processUserInput(userInput);
			showToUser(command.getSuccessMessage() + "\n\n");
		} catch (Exception e) {
			showToUser(e.getMessage() + "\n\n");
		}
	}
	
	/**
	 * This method formats the tasks in the task list into a user-friendly display
	 * 
	 * @param taskList	the task list to format
	 * @return			a String containing the formatted task list display
	 */
	public static String createTaskListDisplay(ArrayList<Task> taskList) {
		if (taskList.size() > 0) {
			StringBuilder message = new StringBuilder();
			int taskNumber = 1;
			boolean isFirstEvent = true;
			boolean isFirstDeadline = true;
			boolean isFirstUnscheduled = true;
			
			for (Task task : taskList) {
				LocalDateTime start = task.getStartDateTime();
				LocalDateTime end = task.getEndDateTime();
				
				if (end == null && start == null) {
					isFirstUnscheduled = writeUnscheduledToList(message, taskNumber++, task, isFirstUnscheduled);
				} else if (start == null) {
					isFirstDeadline = writeDeadlineToList(message, taskNumber++, task, isFirstDeadline);
				} else {
					isFirstEvent = writeEventToList(message, taskNumber++, task, isFirstEvent);
				}
			}
			return message.toString();
		} else {
			return MESSAGE_NO_TASKS;
		}
	}

	/**
	 * Write an event task in the proper formatting to the task list display message
	 * @param message		the StringBuilder holding the current task list display message
	 * @param taskNumber	the number associated with the task
	 * @param task			the task to format and display
	 * @param isFirst		whether this is the first event in the display so far
	 * @return				whether this is the first event in the display so far
	 */
	public static boolean writeEventToList(StringBuilder message, 
			int taskNumber, Task task, boolean isFirst) {
		String taskName = task.getName();
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		
		String doneMarker;
		if (task.isDone()) {
			doneMarker = MARKER_DONE;
		} else {
			doneMarker = MARKER_UNCOMPLETED;
		}
		
		if (isFirst) {
			message.append(MESSAGE_EVENTS_HEADER);
			isFirst = false;
		}
		if (start.toLocalDate().compareTo(end.toLocalDate()) == 0) {
			// same start and end date -> only show the end time
			message.append(String.format(MESSAGE_EVENT, doneMarker, taskNumber, taskName, 
					getDateTimeFormat(start), getTimeFormat(end)));
		} else {
			message.append(String.format(MESSAGE_EVENT, doneMarker, taskNumber, taskName, 
					getDateTimeFormat(start), getDateTimeFormat(end)));
		}
		return isFirst;
	}

	/**
	 * Write a deadline task in the proper formatting to the task list display message
	 * @param message		the StringBuilder holding the current task list display message
	 * @param taskNumber	the number associated with the task
	 * @param task			the task to format and display
	 * @param isFirst		whether this is the first deadline in the display so far
	 * @return				whether this is the first deadline in the display so far
	 */
	public static boolean writeDeadlineToList(StringBuilder message,
			int taskNumber, Task task, boolean isFirst) {
		String taskName = task.getName();
		LocalDateTime end = task.getEndDateTime();

		String doneMarker;
		if (task.isDone()) {
			doneMarker = MARKER_DONE;
		} else {
			doneMarker = MARKER_UNCOMPLETED;
		}
		
		if (isFirst) {
			message.append(MESSAGE_DEADLINE_HEADER);
			isFirst = false;
		}
		message.append(String.format(MESSAGE_DEADLINE, doneMarker, taskNumber, taskName,
				getDateFormat(end), getTimeFormat(end)));
		return isFirst;
	}

	/**
	 * Write an unscheduled task in the proper formatting to the task list display message
	 * @param message		the StringBuilder holding the current task list display message
	 * @param taskNumber	the number associated with the task
	 * @param task			the task to format and display
	 * @param isFirst		whether this is the first unscheduled task in the display so far
	 * @return				whether this is the first unscheduled task in the display so far
	 */
	public static boolean writeUnscheduledToList(StringBuilder message, 
			int taskNumber, Task task, boolean isFirst) {
		String taskName = task.getName();

		String doneMarker;
		if (task.isDone()) {
			doneMarker = MARKER_DONE;
		} else {
			doneMarker = MARKER_UNCOMPLETED;
		}
		
		if (isFirst) {
			message.append(MESSAGE_UNSCHEDULED_HEADER);
			isFirst = false;
		}
		message.append(String.format(MESSAGE_UNSCHEDULED, doneMarker, taskNumber, taskName));
		return isFirst;
	}
	
	/**
	 * Add color coding to a string based on the given time.
	 * 
	 * @param message	the string to add color coding to
	 * @param dateTime		the date to determine the color coding
	 * @return			the jansi formatted color coded string
	 */
	public static String addColorCoding(String message, LocalDateTime dateTime) {
		if (dateTime == null) {
			return COLOR_CODE_FUTURE + message + COLOR_CODE_END_TAG;
		} else if (dateTime.compareTo(LocalDateTime.now()) < 0) {
			return COLOR_CODE_OVERDUE + message + COLOR_CODE_END_TAG;
		} else if (dateTime.toLocalDate().compareTo(LocalDate.now()) == 0) {
			return COLOR_CODE_TODAY + message + COLOR_CODE_END_TAG;
		} else if (dateTime.toLocalDate().compareTo(LocalDate.now().plusDays(1)) == 0) {
			return COLOR_CODE_TOMORROW + message + COLOR_CODE_END_TAG;
		} else {
			return COLOR_CODE_FUTURE + message + COLOR_CODE_END_TAG;
		}
	}
	
	/**
	 * Format the date into dd mmm or dd mmm yyyy depending on whether the year is the same as this year.
	 * 
	 * @param dateTime	the LocalDateTime to format
	 * @return			the string in the proper date format
	 */
	public static String getDateFormat(LocalDateTime dateTime) {
		LocalDate date = dateTime.toLocalDate();
		String month = date.getMonth().getDisplayName(TextStyle.SHORT, Locale.ENGLISH);
		String day = date.getDayOfWeek().toString();
		day = day.substring(0, 1).toUpperCase() + day.substring(1).toLowerCase();
		LocalDate today = LocalDate.now();
		String message;
		
		// only display the year if it is different from the current year
		if (dateTime.getYear() != today.getYear()) {
			message = String.format(MESSAGE_DATE_YEAR, day, dateTime.getDayOfMonth(), month, dateTime.getYear());
		} else if (date.compareTo(today) == 0) {
			message = "today";
		} else if (date.compareTo(today.plusDays(1)) == 0) {
			message = "tomorrow";
		} else {
			message = String.format(MESSAGE_DATE, day, dateTime.getDayOfMonth(), month);
		}
		return addColorCoding(message, dateTime);
	}
	
	/**
	 * Format the time into h:mm AM/PM
	 * 
	 * @param dateTime	the LocalDateTime to format
	 * @return			the string in the proper time format
	 */
	public static String getTimeFormat(LocalDateTime dateTime) {
		int hour = dateTime.getHour() % 12;
		if (hour == 0) {
			hour += 12;
		}
		String message;
		if (dateTime.getHour() < 12) {
			message = String.format(MESSAGE_TIME, hour, dateTime.getMinute(), "AM");
		} else {
			message = String.format(MESSAGE_TIME, hour, dateTime.getMinute(), "PM");
		}
		return addColorCoding(message, dateTime);
	}
	
	/**
	 * This method creates a String in the format dd mmm hh:mm, i.e. 24 Oct 13:00
	 * 
	 * @param dateTime	The LocalDateTime with the date and time to format
	 * @return			a String in the format dd mmm hh:mm
	 */
	public static String getDateTimeFormat(LocalDateTime dateTime) {
		return String.format(MESSAGE_DATE_TIME, getDateFormat(dateTime), getTimeFormat(dateTime));
	}
	
```
###### Ui.java
``` java
	/**
	 * Returns the task list that was most recently displayed to the user. 
	 * 
	 * @return 	an ArrayList of tasks that were most recently displayed to the user
	 */
	public static ArrayList<Task> getCurrentTaskList() {
		return currentTaskList;
	}
	
	/**
	 * This method shows a message to the user in the console
	 * 
	 * @param message	the message to display to the user
	 */
	private static void showToUser(String message) {
		System.out.print(ansi().render(message));
		System.out.flush();
	}
	
	/**
	 * This method flags that the user requested to exit the program
	 */
	public static void indicateExit() {
		isRunning = false;
		logger.log(Level.INFO, "exit command was issued - indicated Ui to exit program");
	}
}
```
###### Undo.java
``` java
import java.util.EmptyStackException;

/**
 * Undo command to handle undoing the last command that made changes to the task list.
 * @author Katherine Coronado
 *
 */

public class Undo extends Command {
	boolean wasExecuted;
	Undoable lastExecuted;
	
	public Undo() {
		this.wasExecuted = false;
		this.lastExecuted = null;
	}
	
	@Override
	public void execute() throws Exception {
		try {
			lastExecuted = logic.getLastUndoable();
		} catch (EmptyStackException e) {
			throw new Exception("No commands to undo.");
		}
		lastExecuted.undo();
		wasExecuted = true;
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return lastExecuted.getUndoMessage();
	}

	public Undoable getLastExecutedCommand() {
		return lastExecuted;
	}
	
	public boolean isExecuted() {
		return wasExecuted;
	}
	
```
###### Undoable.java
``` java
/**
 * This interface should be implemented by any Command that can be undone.
 * @author Katherine Coronado
 *
 */
public interface Undoable {
	public void undo() throws Exception;
	public String getUndoMessage();
}
```
###### Update.java
``` java
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.logging.Level;

/**
 * Update command to handle updating the fields of a task.
 * @author Katherine Coronado
 *
 */

public class Update extends Command implements Undoable {
	private static final String SUCCESS_UPDATE = "\"%s\" updated to %s.";
	private static final String SUCCESS_UPDATE_UNDO = "Update of \"%s\" undone to %s";
	private static final String ERROR_INDEX_INVALID = "The task number specified is not valid.";
	private static final String ERROR_UPDATED_TASK_IS_INVALID = "The update failed because performing these changes would have resulted in an invalid task.";
	private static final String ERROR_TASK_ALREADY_EXISTS = "Update failed because applying these changes would have caused duplicate tasks.";
	private static final String ERROR_CHANGES_DO_NOT_RESULT_IN_DIFFERENT_TASK = "Performing these changes do not result with an updated task that is different from the original.";
	private Task oldTask;
	private Task newTask;
	private DeltaTask changes;
	private int taskIndex;
	private boolean wasExecuted;

```
###### Update.java
``` java
	@Override
	/**
	 * Restore the task to the old state prior to executing the update command.
	 */
	public void undo() throws Exception {
		storageManager.updateTask(newTask, oldTask);
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return String.format(SUCCESS_UPDATE, oldTask.getName(), Ui.getPrintableTaskString(newTask));
	}
	
```
