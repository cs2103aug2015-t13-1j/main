# A0145732H
###### Add.java
``` java
/**
 * Add command to handle adding a task to the task list.
 * @author Katherine Coronado
 *
 */
public class Add extends Command implements Undoable {
	private static final String SUCCESS_ADD = "Added %s.";
	private static final String SUCCESS_ADD_UNDO = "\"%s\" was removed.";
	
	private Task task;
	private boolean wasExecuted;
	
	public Add(Task task) {
		this.task = task;
		this.wasExecuted = false;
	}
	
	@Override
	/**
	 * Add a task to the task list.
	 */
	public void execute() throws Exception {
		// validateDates() will throw an exception if the dates are not valid
		Logic.validateDates(task.getStartDateTime(), task.getEndDateTime());
		storageManager.writeTask(task);
		wasExecuted = true;
	}

	@Override
	/**
	 * Remove the task added by this instance of Add.
	 */
	public void undo() throws Exception {
		storageManager.removeTask(task);
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return String.format(SUCCESS_ADD, Ui.getPrintableTaskString(task));
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Add other = (Add)obj;
		boolean isTaskEqual = (task == null && other.getTask() == null) || (task != null && task.equals(other.getTask()));

		return isTaskEqual && wasExecuted == other.isExecuted();
		
	}
		
	public Task getTask() {
		return this.task;
	}

	public boolean isExecuted() {
		return wasExecuted;
	}
	
	@Override
	public String getUndoMessage() {
		assert(wasExecuted);
		return String.format(SUCCESS_ADD_UNDO, task.getName());
	}
}
```
###### Command.java
``` java
/**
 * Command is a class that contains all the required information for Logic to
 * execute it. It is created by CommandParser's parse method.
 */
public abstract class Command {
	protected static StorageManager storageManager = null;
	
	public abstract void execute() throws Exception;
	public abstract String getSuccessMessage();
```
###### CommandParser.java
``` java
  private static Command initListCommand(ArrayList<String> args) throws Exception {
		if (args.size() == 0) {
			return new List();
		} else {
  		// parse the flags and keywords
  		EnumSet<List.LIST_FLAGS> listFlags = EnumSet.noneOf(List.LIST_FLAGS.class);
  		String[] keywords = null;
  		boolean isAllMarked = false;
  		for (int i = 0; i < args.size(); i++) {
  			String flag = args.get(i);
  			
  			// if "all" flag is marked, remove all flags and break out of the loop
  			if (flag.equals("all")) {
  				listFlags = EnumSet.noneOf(List.LIST_FLAGS.class);
  				isAllMarked = true;
  				break;
  			}
  			
  			switch (flag) {
  				case "unscheduled" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.UNSCHEDULED);
  					}
  					break;
  					
  				case "deadlines" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.DEADLINE);
  					}
  					break;
  					
  				case "events" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.EVENT);
  					}
  					break;
  					
  				case "done" :
  					// fallthrough
  					
  				case "completed" :
  					// fallthrough
  					
  				case "finished" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.COMPLETED);
  					}
  					break;
  					
  				case "uncompleted" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.UNCOMPLETED);
  					}
  					break;
  					
  				case "today" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.TODAY);
  					}
  					break;  					
  					
  				case "tomorrow" :
  					if (!isAllMarked) {
  						listFlags.add(List.LIST_FLAGS.TOMORROW);
  					}
  					break;  					
  					
  				default :
  					// if there are quotation marks, it is a keywords string
  					if (flag.startsWith("\"")) {
  						flag = flag.replace("\"", "");
  						keywords = flag.split(" ");
  					} else {
  						throw new Exception("\"" + flag + "\" is not a recognized marker");
  					}
  					break;
				}
  		}
  		if (keywords == null) {
  			return new List(listFlags);
  		} else {
  			return new List(listFlags, keywords);
  		}
  	}
  }
    
```
###### Exit.java
``` java
/**
 * Exit command to handle closing TaskBuddy cleanly. 
 * @author Katherine Coronado
 *
 */
public class Exit extends Command {
	private boolean wasExecuted;
	
	public Exit() {
		this.wasExecuted = false;
	}
	
	@Override
	/**
	 * Calls the necessary methods to exit TaskBuddy cleanly
	 */
	public void execute() throws Exception {
		// TODO which methods to change to public, etc.
		storageManager.closeStorage();
		Ui.indicateExit();
		wasExecuted = true;
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return "Goodbye\n";
	}

}
```
###### List.java
``` java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;

/**
 * List command used for listing all tasks or for performing a search on the task list
 * @author Katherine Coronado
 *
 */
public class List extends Command {	
	private String[] keywords;
	private ArrayList<Task> taskList;
	EnumSet<LIST_FLAGS> flags;
	private boolean wasExecuted;
	
	public enum LIST_FLAGS {
		UNSCHEDULED, DEADLINE, EVENT, COMPLETED, UNCOMPLETED, TODAY, TOMORROW;
	}
	public static final EnumSet<LIST_FLAGS> LIST_FLAGS_ENUM_SET = EnumSet.allOf(LIST_FLAGS.class);
	
	/** 
	 * Constructs a List object to list all tasks
	 */
	public List() {
		this.keywords = null;
		this.taskList = null;
		this.flags = null;
		this.wasExecuted = false;
	}
	
	public List(EnumSet<LIST_FLAGS> listFlags) {
		this();
		this.flags = listFlags;
	}

	public List(EnumSet<LIST_FLAGS> listFlags, String[] keywords) {
		this(listFlags);
		this.keywords = keywords;
	}

	@Override
	/**
	 * This method handles whether to filter the task list or get the uncompleted tasks list. 
	 */
	public void execute() throws Exception {
		if (keywords != null || flags != null) {
			ArrayList<Task> tasks = storageManager.readAllTasks();
			if (keywords != null) {
				tasks = Logic.searchTasks(keywords);
			}
			if (flags != null) {
				tasks = getFlaggedTasks(tasks);
			}
			taskList = tasks;
		} else {
			taskList = Logic.getUncompletedTasks();
		}
		wasExecuted = true;
	}

	private ArrayList<Task> getFlaggedTasks(ArrayList<Task> flaggedTasks) {
		// keep refining the task list based on which flags are marked
		if (flags.contains(LIST_FLAGS.COMPLETED)) {
			flaggedTasks = Logic.getCompletedTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.UNCOMPLETED)) {
			flaggedTasks = Logic.getUncompletedTasks(flaggedTasks);
		}		
		if (flags.contains(LIST_FLAGS.UNSCHEDULED)) {
			flaggedTasks = Logic.getUnscheduledTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.DEADLINE)) {
			flaggedTasks = Logic.getDeadlineTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.EVENT)) {
			flaggedTasks = Logic.getEvents(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.TODAY)) {
			flaggedTasks = Logic.getTodaysTasks(flaggedTasks);
		}
		if (flags.contains(LIST_FLAGS.TOMORROW)) {
			flaggedTasks = Logic.getTomorrowsTasks(flaggedTasks);
		}
		return flaggedTasks;
	}

	@Override
	/**
	 * Prints out all the tasks in the taskList
	 */
	public String getSuccessMessage() {
		assert(wasExecuted);
		return Ui.createTaskListDisplay(taskList);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		List other = (List)obj;	
		boolean isExecutedEqual = (this.wasExecuted == other.wasExecuted);
		boolean areKeywordsEqual = Arrays.equals(this.keywords, other.keywords);
		boolean areTaskListsEqual = this.taskList.equals(other.taskList);
		boolean areFlagsEqual = this.flags.equals(other.flags);
		return (isExecutedEqual && areKeywordsEqual && areTaskListsEqual && areFlagsEqual);
	}
	
	/**
	 * This method returns the tasks that contain the keywords.
	 * 
	 * @return	ArrayList of tasks generated by the execute() method
	 */
	public ArrayList<Task> getTaskList() {
		// assert that this instance of List has been executed before returning
		assert(taskList != null);
		return this.taskList;
	}
}
```
###### Logic.java
``` java
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Stack;

/*
 *The logic class will process user input from UI, and return the result of the processing to UI.
 *For example, UI gets info about successful execution   of a command. 
 *Errors encountered during input parsing or execution will be propagated by exceptions
 */

public class Logic {
	// error messages for when the date configuration of tasks is invalid
	private static final String ERROR_DATE_INVALID_EVENT = "You cannot have an end time earlier than the start time.";
	
	// constants to define the size of the default task view and the number of each type of task
	public static final int DEFAULT_VIEW_NUM_UNSCHEDULED = 3;
	public static final int DEFAULT_VIEW_NUM_DEADLINES = 6;
	public static final int DEFAULT_VIEW_NUM_EVENTS = 6;
	public static final int DEFAULT_VIEW_MAX_TASKS = 15;
	
	// class variables to keep track of command history for the undo command
	private static Stack<Undoable> undoableHistory = new Stack<Undoable>();
	private static Command lastExecutedCommand = null;
	
	// single instances
	private static StorageManager storageManager = null;
	
```
###### Logic.java
``` java
	public static Command processUserInput(String userInput) throws Exception {
		Command command;
		try {
			command = CommandParser.getCommandFromInput(userInput);
		} catch (Exception e) {
			lastExecutedCommand = null;
			throw new Exception(e.getMessage());			
		}
		
		// this may throw an Exception depending on the command
		try {
			command.execute();
		} catch (Exception e) {
			lastExecutedCommand = null;
			throw new Exception(e.getMessage());
		}
		
		// update command history depending on the command
		lastExecutedCommand = command;
		if (command.getClass() == Undo.class && !undoableHistory.isEmpty()) {
			undoableHistory.pop();
		} else if (Undoable.class.isAssignableFrom(command.getClass())) {
			undoableHistory.push((Undoable)command);
		}
		return command;
	}

	
	
	/**
	 * This method searches the task list for tasks containing all of the given keywords
	 * 
	 * @param keywords	the array of keywords to search for in the task names
	 * @return			an ArrayList of the tasks containing all of the keywords
	 * 					The ArrayList will be empty if no tasks were found.
	 */
	public static ArrayList<Task> searchTasks(String[] keywords) {
		assert(keywords != null);
		
		ArrayList<Task> taskList = storageManager.readAllTasks();
		ArrayList<Task> foundTasks = new ArrayList<Task>();		
		for (int i = 0; i < taskList.size(); i++) {
			int keywordIndex = 0;
			Task currentTask = taskList.get(i);
			
			// check if currentTask contains all of the keywords before adding to foundTasks
			while (keywordIndex < keywords.length) {
				String taskName = currentTask.getName().toLowerCase();
				if (!taskName.contains(keywords[keywordIndex++].toLowerCase())) {
					break;
				}
				if (keywordIndex == keywords.length) {
					foundTasks.add(currentTask);
				}
			}
		}
		return foundTasks;
	}
	
	/**
	 * This method searches for all of the tasks marked as done by the user.
	 * 
	 * @return	an ArrayList of tasks marked as done
	 */
	public static ArrayList<Task> getCompletedTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getCompletedTasks(taskList);
	}
	
	/**
	 * This method searches for all of the tasks marked as done in a given task list
	 * 
	 * @param taskList	the ArrayList to search through to get the completed tasks
	 * @return			an ArrayList of the completed tasks
	 */
	public static ArrayList<Task> getCompletedTasks(ArrayList<Task> taskList) {
		ArrayList<Task> completed = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.isDone()) {
				completed.add(task);
			}
		}
		return completed;	
	}

	/**
	 * This method searches for all of the tasks that are not marked as done by the user.
	 * 
	 * @return	an ArrayList of tasks marked as not done
	 */
	public static ArrayList<Task> getUncompletedTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getUncompletedTasks(taskList);
	}

	/**
	 * This methods searches for all of the tasks that are not marked as done in a given task list
	 * @param taskList	the ArrayList to search through to get the uncompleted tasks
	 * @return			an ArrayList of the uncompleted tasks
	 */
	public static ArrayList<Task> getUncompletedTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> uncompleted = new ArrayList<Task>();
		for (Task task : taskList) {
			if (!task.isDone()) {
				uncompleted.add(task);
			}
		}
		return uncompleted;
	}
	
	/**
	 * This method searches for all of the unscheduled tasks in the entire task list
	 * @return	an ArrayList of the unscheduled tasks
	 */
	public static ArrayList<Task> getUnscheduledTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getUnscheduledTasks(taskList);
	}
	
	/**
	 * This method searches for all of the unscheduled tasks in a specified task list
	 * 
	 * @param taskList	the specified task list to filter for unscheduled tasks
	 * @return			an ArrayList of the found unscheduled tasks
	 */
	public static ArrayList<Task> getUnscheduledTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> unscheduled = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.getStartDateTime() == null && task.getEndDateTime() == null) {
				unscheduled.add(task);
			}
		}
		return unscheduled;	
	}
	
	/**
	 * This method searches for all of the deadline tasks in the entire task list
	 * @return	an ArrayList of the deadline tasks
	 */
	public static ArrayList<Task> getDeadlineTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getDeadlineTasks(taskList);
	}
	
	/**
	 * This method searches for all of the deadlines in a specified task list
	 * 
	 * @param taskList	the specified task list to filter for deadlines
	 * @return			an ArrayList of the found deadlines
	 */
	public static ArrayList<Task> getDeadlineTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> deadlines = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.getStartDateTime() == null && task.getEndDateTime() != null) {
				deadlines.add(task);
			}
		}
		return deadlines;	
	}
	
	/**
	 * This method searches for all of the events in the entire task list
	 * @return	an ArrayList of the events
	 */
	public static ArrayList<Task> getEvents() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getEvents(taskList);
	}
	
	/**
	 * This method searches for all of the events in a specified task list
	 * 
	 * @param taskList	the specified task list to filter for events
	 * @return			an ArrayList of the found events
	 */
	public static ArrayList<Task> getEvents(ArrayList<Task> taskList) {
		assert(taskList != null);
		ArrayList<Task> events = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.getStartDateTime() != null && task.getEndDateTime() != null) {
				events.add(task);
			}
		}
		return events;	
	}
	
	public static ArrayList<Task> getTodaysTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getTodaysTasks(taskList);
	}
	
	public static ArrayList<Task> getTodaysTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		LocalDateTime today = LocalDateTime.now();
		ArrayList<Task> todaysTasks = new ArrayList<Task>();
		for (Task task : taskList) {
			LocalDateTime start = task.getStartDateTime();
			LocalDateTime end = task.getEndDateTime();
			if (start != null && end != null) {
				if (compareDates(start, today) == 0 || compareDates(end, today) == 0) {
					todaysTasks.add(task);
				}
			} else if (end != null) {
				if (compareDates(end, today) == 0) {
					todaysTasks.add(task);
				}
			}
		}
		return todaysTasks;
	}
	
	public static ArrayList<Task> getTomorrowsTasks() {
		ArrayList<Task> taskList = storageManager.readAllTasks();
		return getTomorrowsTasks(taskList);
	}
	
	public static ArrayList<Task> getTomorrowsTasks(ArrayList<Task> taskList) {
		assert(taskList != null);
		LocalDateTime tomorrow = getTomorrowsDate();
		ArrayList<Task> tomorrowsTasks = new ArrayList<Task>();
		for (Task task : taskList) {
			LocalDateTime start = task.getStartDateTime();
			LocalDateTime end = task.getEndDateTime();
			if (start != null && end != null) {
				if (compareDates(start, tomorrow) == 0 || compareDates(end, tomorrow) == 0) {
					tomorrowsTasks.add(task);
				}
			} else if (end != null) {
				if (compareDates(end, tomorrow) == 0) {
					tomorrowsTasks.add(task);
				}
			}
		}
		return tomorrowsTasks;
	}
	
	public static LocalDateTime getTomorrowsDate() {
		LocalDateTime today = LocalDateTime.now();
		return today.plusDays(1);
	}
	
	public static int compareDates(LocalDateTime date1, LocalDateTime date2) {
		if (date1.getYear() < date2.getYear()) {
			return -1;
		} else if (date1.getYear() > date2.getYear()) {
			return 1;
		} else {
			if (date1.getDayOfYear() < date2.getDayOfYear()) {
				return -1;
			} else if (date1.getDayOfYear() > date2.getDayOfYear()) {
				return 1;
			} else {
				return 0;
			}
		}
	}
	
	public static void validateDates(LocalDateTime start, LocalDateTime end) throws Exception {
		if (start == null) {
			// dates are always valid for unscheduled tasks and deadlines
			return;
		}
		boolean areDatesValid = end.compareTo(start) > 0;
		if (!areDatesValid) {
			throw new Exception(ERROR_DATE_INVALID_EVENT);
		}
	}
	
	/**
	 * Get the last undoable command executed by the program.
	 * 
	 * @return	the last Undoable command stored in the command history
	 * @throws EmptyStackException	if there are no more commands in the stack
	 */
	public static Undoable getLastUndoable() throws EmptyStackException {
		return undoableHistory.peek();
	}

	/**
	 * Generate the default task list for the default view.
	 * @return
	 */
	private static ArrayList<Task> getDefaultTaskList() {
		ArrayList<Task> defaultTasks = new ArrayList<Task>();
		ArrayList<Task> uncompleted = getUncompletedTasks();
		ArrayList<Task> uncompletedUnscheduled = getUnscheduledTasks(uncompleted);
		ArrayList<Task> uncompletedDeadlines = getDeadlineTasks(uncompleted);
		ArrayList<Task> uncompletedEvents = getEvents(uncompleted);
		
		int numTasks = 0;
		int tasksForView;
		// display up to 15 tasks
		if (uncompleted.size() < DEFAULT_VIEW_MAX_TASKS) {
			tasksForView = uncompleted.size();
		} else {
			tasksForView = DEFAULT_VIEW_MAX_TASKS;
		}
		// display an even amount of each task type.
		// if there are not enough tasks of a task type, then distribute between the remaining types.
		int eventIndex = 0;
		int deadlineIndex = 0;
		int unscheduledIndex = 0;
		int extraTasks = 0;
		while (numTasks < tasksForView) {
			if (eventIndex < uncompletedEvents.size()) {
				if (eventIndex < DEFAULT_VIEW_NUM_EVENTS) {
					defaultTasks.add(uncompletedEvents.get(eventIndex++));
					numTasks++;				
				} else if (extraTasks > 0) {
					defaultTasks.add(uncompletedEvents.get(eventIndex++));
					numTasks++;				
					extraTasks--;
				}
				if (numTasks == tasksForView) {
					break;
				}
			} else if (eventIndex < DEFAULT_VIEW_NUM_EVENTS) {
				extraTasks++;
				eventIndex++;
			}
			if (deadlineIndex < uncompletedDeadlines.size()) {
				if (deadlineIndex < DEFAULT_VIEW_NUM_DEADLINES) {
					defaultTasks.add(uncompletedDeadlines.get(deadlineIndex++));
					numTasks++;				
				} else if (extraTasks > 0) {
					defaultTasks.add(uncompletedDeadlines.get(deadlineIndex++));
					numTasks++;				
					extraTasks--;
				}
				if (numTasks == tasksForView) {
					break;
				}
			} else if (deadlineIndex < DEFAULT_VIEW_NUM_DEADLINES) {
				extraTasks++;
				deadlineIndex++;
			}
			if (unscheduledIndex < uncompletedUnscheduled.size()) {
				if (unscheduledIndex < DEFAULT_VIEW_NUM_UNSCHEDULED) {
					defaultTasks.add(uncompletedUnscheduled.get(unscheduledIndex++));
					numTasks++;				
				} else if (extraTasks > 0) {
					defaultTasks.add(uncompletedUnscheduled.get(unscheduledIndex++));
					numTasks++;				
					extraTasks--;
				}
				if (numTasks == tasksForView) {
					break;
				}
			}else if (unscheduledIndex < DEFAULT_VIEW_NUM_UNSCHEDULED) {
				extraTasks++;
				unscheduledIndex++;
			}
		}
		
		defaultTasks.sort(null);
		return defaultTasks;
	}

	/**
	 * Get the task list to correspond to subsequent references by index
	 * 
	 * @return	the list of tasks
	 */
	public static ArrayList<Task> updateCurrentTaskList() {
		if (lastExecutedCommand != null && lastExecutedCommand.getClass() == List.class) {
			List command = (List)lastExecutedCommand;
			return command.getTaskList();
		} else {
			return getDefaultTaskList();
		}
	}
	
	/**
	 * Generate the default view depending on whether a list was just shown or not
	 * 
	 * @return	a string representation of the default view to show
	 */
	public static String getDefaultView() {
		if (lastExecutedCommand != null && lastExecutedCommand.getClass() == List.class) {
			return "";
		} else {
			ArrayList<Task> taskList = Ui.getCurrentTaskList();
			return Ui.createTaskListDisplay(taskList) + "\n\n";
		}
	}
}
```
###### LogicTest.java
``` java
	@Test
	public void testSearchTasks() {
		StorageManagerStub sm = new StorageManagerStub();
		Logic.init(sm);
				
		Task apple = new Task("apple", false);
		Task banana = new Task("banana", false);
		Task baby = new Task("baby", false);
		Task appleBanana = new Task("apple banana", false);
		
		sm.writeTask(apple);
		sm.writeTask(banana);
		sm.writeTask(baby);
		sm.writeTask(appleBanana);
		
		ArrayList<Task> expected = new ArrayList<Task>();
		ArrayList<Task> actual;
		
		// test searching "b"
		// equivalence partition for searching for one keyword
		actual = Logic.searchTasks(new String[] {"b"});
		expected.add(banana);
		expected.add(baby);
		expected.add(appleBanana);
		assert(actual.equals(expected));
		
		// test searching "apple b"
		// equivalence partition for searching with more than one keyword
		actual = Logic.searchTasks(new String[] {"apple", "b"});
		expected.clear();
		expected.add(appleBanana);
		assert(actual.equals(expected));
		
		// test searching "c"
		// equivalence partition for searching and not finding anything
		actual = Logic.searchTasks(new String[] {"c"});
		expected.clear();
		assert(actual.equals(expected));
	}
	
	@Test
	public void testGetTasksMethods() {
		StorageManagerStub sm = new StorageManagerStub();
		Logic.init(sm);
		
		Task t1 = new Task("1", true);
		Task t2 = new Task("2", false);
		Task t3 = new Task("3", LocalDateTime.now(), true);
		Task t4 = new Task("4", LocalDateTime.now().plusDays(1), false);
		Task t5 = new Task("5", LocalDateTime.now().plusDays(2), false);
		Task t6 = new Task("6", LocalDateTime.now(), LocalDateTime.now().plusDays(1), true);
		Task t7 = new Task("7", LocalDateTime.now().plusDays(1), LocalDateTime.now().plusDays(2), false);
		Task t8 = new Task("8", LocalDateTime.now().plusDays(2), LocalDateTime.now().plusDays(3), false);
		
		sm.writeTask(t1);
		sm.writeTask(t2);
		sm.writeTask(t3);
		sm.writeTask(t4);
		sm.writeTask(t5);
		sm.writeTask(t6);
		sm.writeTask(t7);
		sm.writeTask(t8);
		
		// test getCompletedTasks()
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(t1);
		expected.add(t3);
		expected.add(t6);
		
		ArrayList<Task> actual = Logic.getCompletedTasks();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getUncompletedTasks()
		expected.add(t2);
		expected.add(t4);
		expected.add(t5);
		expected.add(t7);
		expected.add(t8);
		
		actual = Logic.getUncompletedTasks();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getUnscheduledTasks()
		expected.add(t1);
		expected.add(t2);
		
		actual = Logic.getUnscheduledTasks();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getDeadlineTasks()
		expected.add(t3);
		expected.add(t4);
		expected.add(t5);
		
		actual = Logic.getDeadlineTasks();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getEvents()
		expected.add(t6);
		expected.add(t7);
		expected.add(t8);
		
		actual = Logic.getEvents();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getTodaysTasks()
		expected.add(t3);
		expected.add(t4);
		
		actual = Logic.getTodaysTasks();
		assert(actual.equals(expected));
		expected.clear();
		
		// test getTomorrowsTasks()
		expected.add(t4);
		expected.add(t6);
		expected.add(t7);
		
		actual = Logic.getTomorrowsTasks();
		assert(actual.equals(expected));
		expected.clear();
	}
	
	@Test
	public void testCompareDates() {
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime tomorrow = now.plusDays(1);
		
		int comparison = Logic.compareDates(now, tomorrow);
		assert(comparison < 0);
		comparison = Logic.compareDates(tomorrow, now);
		assert(comparison > 0);
		comparison = Logic.compareDates(now, now);
		assert(comparison == 0);
	}
	
	@Test
	public void testValidateDates() {
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime later = now.plusSeconds(1);
		
		// now is before later - should be valid
		try {
			Logic.validateDates(now, later);
		} catch (Exception e) {
			fail();
		}

		// both dates are equal - should throw exception
		Exception exception = null;
		try {
			Logic.validateDates(now, now);
		} catch (Exception e) {
			exception = e;
		}
		assert(exception != null);
		
		// later is before now - should throw exception
		exception = null;
		try {
			Logic.validateDates(later, now);
		} catch (Exception e) {
			exception = e;
		}
		assert(exception != null);
	}
	
	@Test
	public void testUpdateCurrentTaskList() {
		StorageManagerStub sm = new StorageManagerStub();
		ArrayList<Task> unscheduled = new ArrayList<Task>();
		ArrayList<Task> deadlines = new ArrayList<Task>();
		ArrayList<Task> events = new ArrayList<Task>();
		ArrayList<Task> actual;
		
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			unscheduled.add(new Task("unscheduled " + i, false));
			deadlines.add(new Task("deadline " + i, LocalDateTime.now(), false));
			events.add(new Task("event " + i, LocalDateTime.now(), LocalDateTime.now().plusDays(1), false));
		}
		
		/* test that default display shows the right number of each 
			task type when there are enough of each type */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(unscheduled.get(i));
			sm.writeTask(deadlines.get(i));
			sm.writeTask(events.get(i));
		}
		actual = Logic.updateCurrentTaskList();
		// these get methods are tested in the test suite - they are assumed to work here
		assert(Logic.getUnscheduledTasks(actual).size() == Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(Logic.getDeadlineTasks(actual).size() == Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(Logic.getEvents(actual).size() == Logic.DEFAULT_VIEW_NUM_EVENTS);
		sm.clearTasks();
		
		/* test that the default number of tasks is displayed when 
			there is only one type of task */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(events.get(i));
		}
		actual = Logic.updateCurrentTaskList();
		assert(actual.size() == Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
		/* test that the correct number of tasks is displayed when
		 * there are only two types of tasks 
		 */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(unscheduled.get(i));
			sm.writeTask(deadlines.get(i));
		}
		actual = Logic.updateCurrentTaskList();
		assert(Logic.getUnscheduledTasks().size() > Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(Logic.getDeadlineTasks().size() > Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(actual.size() == Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
		/* test that the correct number of tasks is displayed when
		 * there are not enough of one type of task, but enough of 
		 * the other two to compensate. 
		 */
		for (int i = 0; i < Logic.DEFAULT_VIEW_MAX_TASKS; i++) {
			sm.writeTask(unscheduled.get(i));
			sm.writeTask(deadlines.get(i));
		}
		sm.writeTask(events.get(0));
		actual = Logic.updateCurrentTaskList();
		assert(Logic.getUnscheduledTasks().size() > Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(Logic.getDeadlineTasks().size() > Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(Logic.getEvents().size() < Logic.DEFAULT_VIEW_NUM_EVENTS);
		assert(actual.size() == Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
		/* test that the correct number of tasks is displayed when
		 * there are not enough tasks
		 */
		sm.writeTask(unscheduled.get(0));
		sm.writeTask(deadlines.get(0));
		sm.writeTask(events.get(0));
		actual = Logic.updateCurrentTaskList();
		assert(Logic.getUnscheduledTasks().size() < Logic.DEFAULT_VIEW_NUM_UNSCHEDULED);
		assert(Logic.getDeadlineTasks().size() < Logic.DEFAULT_VIEW_NUM_DEADLINES);
		assert(Logic.getEvents().size() < Logic.DEFAULT_VIEW_NUM_EVENTS);
		assert(actual.size() < Logic.DEFAULT_VIEW_MAX_TASKS);
		sm.clearTasks();
		
	}
}
```
###### Remove.java
``` java
import java.util.ArrayList;

/**
 * Remove command to handle removing a task from the task list.
 * @author Katherine Coronado
 *
 */
public class Remove extends Command implements Undoable {
	private static final String SUCCESS_REMOVE = "\"%s\" was removed.";
	private static final String SUCCESS_REMOVE_UNDO = "\"%s\" was re-added.";
	private static final String ERROR_INDEX_INVALID = "The task number specified is not valid.";
	
	private Task task;
	private int index;
	private boolean isExecuted;
	
	public Remove(int taskNumber) {
		this.index = taskNumber - 1;
		this.isExecuted = false;
		this.task = null;
	}
	
	@Override
	/**
	 * Remove the task from the task list.
	 */
	public void execute() throws Exception {
		ArrayList<Task> taskList = Ui.getCurrentTaskList();
		if (index >= 0 && index < taskList.size()) {
			task = taskList.get(index);
			storageManager.removeTask(task);
		} else {
			throw new Exception(ERROR_INDEX_INVALID);
		}
		isExecuted = true;
	}

	@Override
	/**
	 * Re-add the task that was removed by this instance of Remove.
	 */
	public void undo() throws Exception {
		storageManager.writeTask(task);
	}

	@Override
	public String getSuccessMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_REMOVE, task.getName());
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Remove other = (Remove)obj;
		boolean isTaskEqual = (task == null && other.getTask() == null) || (task != null && task.equals(other.getTask()));
		
		return isTaskEqual && isExecuted == other.isExecuted() && index == other.getTaskIndex();
		}
	
		public Task getTask() {
		return this.task;
	}

	public int getTaskIndex() {
		return index;
	}
	
	public boolean isExecuted() {
		return isExecuted;
	}
	
	@Override
	public String getUndoMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_REMOVE_UNDO, task.getName());
	}
}
```
###### StorageManager.java
``` java
	public ArrayList<Task> readAllTasks() {
		ArrayList<Task> taskArrayList = new ArrayList<Task>();
		taskArrayList.addAll(Arrays.asList(TASK_LIST));
		taskArrayList.sort(null);
		return taskArrayList;
	}

```
###### StorageManager.java
``` java
	/**
	 * This method removes a given task from the file
	 * 
	 * @param task
	 * @throws Exception	if the task was unable to be removed
	 */
	public void removeTask(Task task) throws Exception {
		boolean isRemoved = false;
		try {
			Gson gson = new Gson();
			ArrayList<Task> taskListTransition;
			Task[] taskListToUpdate;
			
			taskListTransition = new ArrayList<Task> (Arrays.asList(TASK_LIST));
			
			isRemoved = taskListTransition.remove(task);
			
			taskListToUpdate = taskListTransition.toArray(new Task[taskListTransition.size()]);
			
			TASK_LIST = new Task[taskListToUpdate.length];
			TASK_LIST = taskListToUpdate;
			
			// hacky
			bufferedWriter.close();
			fileWriter.close();
			fileWriter = new FileWriter(file.getAbsoluteFile());
			bufferedWriter = new BufferedWriter(fileWriter);
			
			gson.toJson(taskListToUpdate, bufferedWriter);
			bufferedWriter.flush();
			
		} catch (Exception e) {
			// TODO is this what would throw the exception?
			// if so we should re-add the removed task to the local copy to reflect the file
			isRemoved = false;
			throw new Exception("Error saving changes to file.");
		}
		
		if (!isRemoved) {
			throw new Exception("\"" + task.getName() + "\" was not found.");
		}
	}
	
```
###### StorageManager.java
``` java
	/**
	 * This method updates a task in the task list with the new task.
	 * 
	 * @param oldTask		the task to search for and update
	 * @param newTask		the updated version of the task to replace the old task
	 * @throws Exception	if there are no tasks or if the old task was not found
	 */
	public void updateTask(Task oldTask, Task newTask) throws Exception {
		if (TASK_LIST.length == 0) {
			throw new Exception("You currently do not have any tasks saved.");
		}
		removeTask(oldTask);
		writeTask(newTask);
	}
}
```
###### StorageManagerTest.java
``` java
	@Test
	// testing whether the tasks sort properly
	public void testReadAllTasks() throws Exception {
		Task e1 = new Task("event 1", LocalDateTime.of(2015, 1, 1, 1, 0), LocalDateTime.of(2015, 1, 2, 1, 0), false);
		Task e2 = new Task("event 2", LocalDateTime.of(2015, 1, 1, 1, 0), LocalDateTime.of(2015, 1, 3, 1, 0), false);
		Task e3 = new Task("event 3", LocalDateTime.of(2015, 1, 2, 1, 0), LocalDateTime.of(2015, 1, 3, 1, 0), false);
		Task e4 = new Task("event 4", LocalDateTime.of(2015, 1, 2, 1, 0), LocalDateTime.of(2015, 1, 3, 1, 0), false);
		Task d1 = new Task("deadline 1", LocalDateTime.of(2015, 1, 1, 1, 0), false);
		Task d2 = new Task("deadline 2", LocalDateTime.of(2015, 1, 2, 1, 0), false);
		Task d3 = new Task("deadline 3", LocalDateTime.of(2015, 1, 2, 1, 0), false);
		Task f1 = new Task("floating 1", false);
		Task f2 = new Task("floating 2", false);
		
		StorageManager.writeTask(e1);
		StorageManager.writeTask(d1);
		StorageManager.writeTask(f1);
		StorageManager.writeTask(e2);
		StorageManager.writeTask(d2);
		StorageManager.writeTask(f2);
		StorageManager.writeTask(e3);
		StorageManager.writeTask(d3);
		StorageManager.writeTask(e4);
		
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(e1);
		expected.add(e2);
		expected.add(e3);
		expected.add(e4);
		expected.add(d1);
		expected.add(d2);
		expected.add(d3);
		expected.add(f1);
		expected.add(f2);
		
		ArrayList<Task> actual = StorageManager.readAllTasks();
		assertEquals(expected, actual);
		
		for (Task task : expected) {
			StorageManager.removeTask(task);
		}
	}
*/
}
```
###### Task.java
``` java
	@Override
	/**
	 * Tasks are ordered by events, deadlines, then unscheduled tasks (ascending).
	 * Events are compared to other events first by start date, then by end date, then by name.
	 * Deadlines are compared to other deadlines first by end date, then by name.
	 * Unscheduled tasks are compared to other unscheduled tasks by name.
	 */
	public int compareTo(Task otherTask) {
		if (otherTask == null) {
			throw new NullPointerException();
		}
		if (this.equals(otherTask)) {
			return 0;
		}
		
		LocalDateTime otherStart = otherTask.getStartDateTime();
		LocalDateTime otherEnd = otherTask.getEndDateTime();
		String otherName = otherTask.getName();
		
		// If this is an event:
		if (this.start != null && this.end != null) {
			// if other is not an event: this < other
			if (otherStart == null) {
				return -1;
			} else {
				// sort order: start date, end date, name
				if (!this.start.equals(otherStart)) {
					return (this.start.compareTo(otherStart));
				} else if (!this.end.equals(otherEnd)) {
					return (this.end.compareTo(otherEnd));
				} else {
					return (this.name.compareTo(otherName));
				}
			}
		}
		
		// If this is a deadline task - sorted by end date, then name
		if (this.end != null && this.start == null) {
			if (otherStart != null) {
				// this is a deadline, other is an event --> this > other
				return 1;
			} else if (otherEnd == null) {
				// this is a deadline, other is unscheduled --> this < other
				return -1;
			} else {
				// both this and other are deadlines: sort by end date then by name
				if (!this.end.equals(otherEnd)) {
					return (this.end.compareTo(otherEnd));
				} else {
					return (this.name.compareTo(otherName));
				}
			}
		}
		// 3. unscheduled tasks - sorted by name
		if (this.end == null && this.start == null) {
			if (otherStart != null || otherEnd != null) {
				// this is a unscheduled, other is not unscheduled --> this > other
				return 1;
			} else {
				// both are unscheduled --> sort by name
				return (this.name.compareTo(otherName));
			}
		}
		return 0;
		
	}
}
```
###### Ui.java
``` java
import org.fusesource.jansi.AnsiConsole;
import static org.fusesource.jansi.Ansi.*;
import java.time.LocalDateTime;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Scanner;

/**
 * The UI class handles all user input and output to the screen.
 * It sends the user input to the Logic component for processing,
 * and it handles displaying the command feedback and errors to the user. 
 * Exceptions thrown by the Logic component to indicate errors are handled by UI. 
 * 
 * @author Katherine Coronado
 *
 */

public class Ui {
	/** text marker to indicate whether a task is completed or not when displaying tasks **/
	private static final String MARKER_UNCOMPLETED = "     ";
	private static final String MARKER_DONE = "DONE ";
	
	/** Jansi tags for color coding strings based on the date **/
	private static final String COLOR_CODE_END_TAG = "|@";
	private static final String COLOR_CODE_FUTURE = "@|CYAN ";
	private static final String COLOR_CODE_TOMORROW = "@|GREEN ";
	private static final String COLOR_CODE_TODAY = "@|YELLOW ";
	private static final String COLOR_CODE_OVERDUE = "@|RED ";
	
	/** messages to be displayed to the user **/
	private static final String MESSAGE_WELCOME = "Welcome to TaskBuddy!\n\n";
	private static final String MESSAGE_COMMAND_PROMPT = "> ";
	
	/** messages and message formats for tasks in the task list display **/
	private static final String MESSAGE_NO_TASKS = "No tasks to display.";
	private static final String MESSAGE_UNSCHEDULED = "%s%d. %s\n";
	private static final String MESSAGE_DEADLINE = "%s%d. %s\n\tdue %s at %s\n";
	private static final String MESSAGE_EVENT = "%s%d. %s\n\t%s to %s\n";
	private static final String MESSAGE_DATE = "%s, %d %s";
	private static final String MESSAGE_DATE_YEAR = MESSAGE_DATE + " %d";
	private static final String MESSAGE_TIME = "%d:%02d %s";
	
	private static boolean isRunning;
	private static Scanner keyboard;
	private static ArrayList<Task> currentTaskList;
	
	public static void main(String[] args) {
		taskBuddyInit();
		displayWelcomeMessage();
		while (isRunning) {
			currentTaskList = Logic.updateCurrentTaskList();
			showToUser(Logic.getDefaultView());
			showToUser(MESSAGE_COMMAND_PROMPT);
			String userInput = getUserInput();
			executeUserInput(userInput);
		}
		taskBuddyClose();
	}

	/** 
	 * This method gets user input from the keyboard
	 * 
	 * @return	the user's input string
	 */
	private static String getUserInput() {
		return keyboard.nextLine();
	}

	/**
	 * This method initiates Task Buddy by initializing the class variables
	 */
	private static void taskBuddyInit() {
		AnsiConsole.systemInstall();
		keyboard = new Scanner(System.in);
		isRunning = true;
		Logic.init(new StorageManager());
	}

	/**
	 * This method displays a welcome message and other relevant tasks to the user
	 * upon opening the program.
	 */
	private static void displayWelcomeMessage() {
		showToUser(MESSAGE_WELCOME);
		// TODO possibly show the list of upcoming tasks to the user
	}

	/**
	 * This method closes Task Buddy
	 */
	private static void taskBuddyClose() {
		Logic.close();
		keyboard.close();
		AnsiConsole.systemUninstall();
		System.exit(0);
	}
	
	/**
	 * This method will handle the user's input to be evaluated and executed
	 * 
	 * @param userInput	the string entered by the user
	 */
	public static void executeUserInput(String userInput) {
		try {
			Command command = Logic.processUserInput(userInput);
			showToUser(command.getSuccessMessage() + "\n\n");
		} catch (Exception e) {
			showToUser(e.getMessage() + "\n\n");
		}
	}
	
	/**
	 * This method formats the tasks in the task list into a user-friendly display
	 * 
	 * @param taskList	the task list to format
	 * @return			a String containing the formatted task list display
	 */
	public static String createTaskListDisplay(ArrayList<Task> taskList) {
		if (taskList.size() > 0) {
			StringBuilder message = new StringBuilder();
			int taskNumber = 1;
			boolean isFirstEvent = true;
			boolean isFirstDeadline = true;
			boolean isFirstUnscheduled = true;
			
			for (Task task : taskList) {
				LocalDateTime start = task.getStartDateTime();
				LocalDateTime end = task.getEndDateTime();
				String taskName = task.getName();
				String doneMarker;
				if (task.isDone()) {
					doneMarker = MARKER_DONE;
				} else {
					doneMarker = MARKER_UNCOMPLETED;
				}
				
				if (end == null && start == null) {
					if (isFirstUnscheduled) {
						message.append("\nUnscheduled tasks:\n");
						isFirstUnscheduled = false;
					}
					message.append(String.format(MESSAGE_UNSCHEDULED, doneMarker, taskNumber++, taskName));
				} else if (start == null) {
					if (isFirstDeadline) {
						message.append("\nDeadlines:\n");
						isFirstDeadline = false;
					}
					message.append(String.format(MESSAGE_DEADLINE, doneMarker, taskNumber++, taskName,
							getDateFormat(end), getTimeFormat(end)));
				} else {
					if (isFirstEvent) {
						message.append("\nEvents:\n");
						isFirstEvent = false;
					}
					if (Logic.compareDates(start, end) == 0) {
						// same start and end date -> only show the end time
						message.append(String.format(MESSAGE_EVENT, doneMarker, taskNumber++, taskName, 
								getDateTimeFormat(start), getTimeFormat(end)));
					} else {
						message.append(String.format(MESSAGE_EVENT, doneMarker, taskNumber++, taskName, 
								getDateTimeFormat(start), getDateTimeFormat(end)));
					}
				}
			}
			return message.toString();
		} else {
			return MESSAGE_NO_TASKS;
		}
	}
	
	/**
	 * Add color coding to a string based on the given time.
	 * 
	 * @param message	the string to add color coding to
	 * @param dateTime	the date to determine the color coding
	 * @return			the jansi formatted color coded string
	 */
	private static String addColorCoding(String message, LocalDateTime dateTime) {
		if (dateTime == null) {
			return COLOR_CODE_FUTURE + message + COLOR_CODE_END_TAG;
		} else if (dateTime.compareTo(LocalDateTime.now()) < 0) {
			return COLOR_CODE_OVERDUE + message + COLOR_CODE_END_TAG;
		} else if (Logic.compareDates(dateTime, LocalDateTime.now()) == 0) {
			return COLOR_CODE_TODAY + message + COLOR_CODE_END_TAG;
		} else if (Logic.compareDates(dateTime, Logic.getTomorrowsDate()) == 0) {
			return COLOR_CODE_TOMORROW + message + COLOR_CODE_END_TAG;
		} else {
			return COLOR_CODE_FUTURE + message + COLOR_CODE_END_TAG;
		}
	}
	
	/**
	 * Format the date into dd mmm or dd mmm yyyy depending on whether the year is the same as this year.
	 * 
	 * @param dateTime	the LocalDateTime to format
	 * @return			the string in the proper date format
	 */
	private static String getDateFormat(LocalDateTime dateTime) {
		String month = dateTime.getMonth().getDisplayName(TextStyle.SHORT, Locale.ENGLISH);
		String day = dateTime.getDayOfWeek().toString();
		day = day.substring(0, 1).toUpperCase() + day.substring(1).toLowerCase();
		LocalDateTime today = LocalDateTime.now();
		String message;
		
		// only display the year if it is different from the current year
		if (dateTime.getYear() != today.getYear()) {
			message = String.format(MESSAGE_DATE_YEAR, day, dateTime.getDayOfMonth(), month, dateTime.getYear());
		} else if (Logic.compareDates(dateTime, LocalDateTime.now()) == 0) {
			message = "today";
		} else if (Logic.compareDates(dateTime, Logic.getTomorrowsDate()) == 0) {
			message = "tomorrow";
		} else {
			message = String.format(MESSAGE_DATE, day, dateTime.getDayOfMonth(), month);
		}
//		return message;
		return addColorCoding(message, dateTime);
	}
	
	/**
	 * Format the time into h:mm AM/PM
	 * 
	 * @param dateTime	the LocalDateTime to format
	 * @return			the string in the proper time format
	 */
	private static String getTimeFormat(LocalDateTime dateTime) {
		int hour = dateTime.getHour() % 12;
		if (hour == 0) {
			hour += 12;
		}
		String message;
		if (dateTime.getHour() < 12) {
			message = String.format(MESSAGE_TIME, hour, dateTime.getMinute(), "AM");
		} else {
			message = String.format(MESSAGE_TIME, hour, dateTime.getMinute(), "PM");
		}
//		return message;
		return addColorCoding(message, dateTime);
	}
	
	/**
	 * This method creates a String in the format dd mmm hh:mm, i.e. 24 Oct 13:00
	 * 
	 * @param dateTime	The LocalDateTime with the date and time to format
	 * @return			a String in the format dd mmm hh:mm
	 */
	private static String getDateTimeFormat(LocalDateTime dateTime) {
		return getDateFormat(dateTime) + " at " + getTimeFormat(dateTime);
	}
	
```
###### Ui.java
``` java
	/**
	 * Returns the task list that was most recently displayed to the user. 
	 * 
	 * @return 	an ArrayList of tasks that were most recently displayed to the user,
	 * 			or null if the most recent command was not a List command
	 */
	public static ArrayList<Task> getCurrentTaskList() {
		return currentTaskList;
	}
	
	/**
	 * This method shows a message to the user in the console
	 * 
	 * @param message	the message to display to the user
	 */
	private static void showToUser(String message) {
		System.out.print(ansi().render(message));
		System.out.flush();
	}
	
	/**
	 * This method flags that the user requested to exit the program
	 */
	public static void indicateExit() {
		isRunning = false;
	}
}
```
###### Undo.java
``` java
import java.util.EmptyStackException;

/**
 * Undo command to handle undoing the last command that made changes to the task list.
 * @author Katherine Coronado
 *
 */

public class Undo extends Command {
	boolean wasExecuted;
	Undoable lastExecuted;
	
	public Undo() {
		this.wasExecuted = false;
		this.lastExecuted = null;
	}
	
	@Override
	public void execute() throws Exception {
		try {
			lastExecuted = Logic.getLastUndoable();
		} catch (EmptyStackException e) {
			throw new Exception("No commands to undo.");
		}
		lastExecuted.undo();
		wasExecuted = true;
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return lastExecuted.getUndoMessage();
	}

	public Undoable getLastExecutedCommand() {
		return lastExecuted;
	}
	
	public boolean isExecuted() {
		return wasExecuted;
	}
	
```
###### Undoable.java
``` java
/**
 * This interface should be implemented by any Command that can be undone.
 * @author Katherine Coronado
 *
 */
public interface Undoable {
	public void undo() throws Exception;
	public String getUndoMessage();
}
```
###### Update.java
``` java
import java.time.LocalDateTime;
import java.util.ArrayList;

/**
 * Update command to handle updating the fields of a task.
 * @author Katherine Coronado
 *
 */

public class Update extends Command implements Undoable {
	private static final String SUCCESS_UPDATE = "\"%s\" updated to %s.";
	private static final String SUCCESS_UPDATE_UNDO = "Update of \"%s\" undone to %s";
	private static final String ERROR_INDEX_INVALID = "The task number specified is not valid.";
	private static final String ERROR_UPDATED_TASK_IS_INVALID = "The update failed because performing these changes would have resulted in an invalid task.";	
	private Task oldTask;
	private Task newTask;
	private DeltaTask changes;
	private int taskIndex;
	private boolean wasExecuted;

```
###### Update.java
``` java
	@Override
	/**
	 * Update the task.
	 */
	public void execute() throws Exception {
		ArrayList<Task> taskList = Ui.getCurrentTaskList();
		if (taskIndex >= 0 && taskIndex < taskList.size()) {
			oldTask = taskList.get(taskIndex);
			createUpdatedTask();
			// validateDates() will throw an exception if the dates are not valid
			Logic.validateDates(newTask.getStartDateTime(), newTask.getEndDateTime());
			storageManager.updateTask(oldTask, newTask);
		} else {
			throw new Exception(ERROR_INDEX_INVALID);
		}
		wasExecuted = true;
	}

```
###### Update.java
``` java
	@Override
	/**
	 * Restore the task to the old state prior to executing the update command.
	 */
	public void undo() throws Exception {
		storageManager.updateTask(newTask, oldTask);
	}

	@Override
	public String getSuccessMessage() {
		assert(wasExecuted);
		return String.format(SUCCESS_UPDATE, oldTask.getName(), Ui.getPrintableTaskString(newTask));
	}
	
```
