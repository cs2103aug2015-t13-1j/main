# A0126270N
###### Add.java
``` java
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Add other = (Add)obj;
		boolean isTaskEqual = (task == null && other.getTask() == null) || (task != null && task.equals(other.getTask()));

		return isTaskEqual && wasExecuted == other.isExecuted();
	}
		
	public Task getTask() {
		return task;
	}

	public boolean isExecuted() {
		return wasExecuted;
	}
	
	
}
```
###### Command.java
``` java
	public static void setStorageManager(StorageManager sm) {
		assert(sm != null);
		storageManager = sm;
	}
}
```
###### CommandParser.java
``` java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.EnumSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * CommandParser parses user's input to create Command objects that have the
 * appropriate fields initialised. For example, the "remove" command requires the
 * taskName field to be initialised.
 * 
 * @author Dickson
 *
 */

public class CommandParser {
	// error messages for thrown exceptions, public to facilitate testing
	public static final String ERROR_NOTHING_ENTERED = "Please enter a command.";
	public static final String ERROR_INVALID_QUOTE_COUNT = "There is text inside a quote without a corresponding closing quote, or there are too many quotes.";
	public static final String ERROR_INVALID_COMMAND = "\"%s\" is not a supported command.";
  public static final String ERROR_EXPECTED_ONE_TASK_NUM = "Please indicate only one task to %s.";
  public static final String ERROR_NUMBER_FORMAT = "Please specify a valid task number.";
	public static final String ERROR_INVALID_DATE_AND_TIME = "%s is not a date and time in dd-mm hh:mm or dd-mm-yyyy hh:mm format, where hh:mm is in 24-hour time.";
	public static final String ERROR_COULD_NOT_DETERMINE_TASK_TYPE_TO_ADD = "The type of task to be added could not be determined.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_ADD = "Please specify the name for the new task, and its start and end date and time if appropriate.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_REMOVE = "Please specify the task number to be removed.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_DONE = "Please specify the task number to be marked completed.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE = "Please specify the task to be updated, and fields to be modified or removed.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_MOVE = "Please specify the path (enclosed in quotes) to the folder that should be used for task storage.";
	public static final String ERROR_INVALID_FIELD_TO_UPDATE = "A new %s was not found after %s, or you are trying to perform multiple modifications to that field.";
	public static final String ERROR_INVALID_FIELD_TO_REMOVE = "The %s field could not be removed because you are trying to perform multiple modifications to that field.";
	public static final String ERROR_UNRECOGNIZED_UPDATE_TOKEN = "%s is not a valid update token.";
	public static final String ERROR_NAME_SHOULD_BE_IN_QUOTES = "The task name should be surrounded by quotes.";
	public static final String ERROR_NAME_SHOULD_CONTAIN_NON_WHITESPACE_CHARS = "The task name should not be composed entirely of spaces.";
	public static final String ERROR_FOLDER_PATH_SHOULD_BE_IN_QUOTES = "The folder path should be surrounded by quotes.";
	 
	// positions in the command input
	private static final int POSITION_COMMAND_TYPE = 0;
  private static final int POSITION_FIRST_PARAM = 1;
    
  // the regex pattern to split input by spaces, except if there is a quoted string. 
//   E.g read LOTR in the string '"read LOTR" by 21-02-2015 12:00' is 1 token 
  // because of the way tokenizing is done, an argument like date and time which has a space between them is counted as 2 arguments
	private static final Pattern splitter = Pattern.compile("([^\"]\\S*|\".+?\")\\s*");
	
	// the default formatter used to parse date and time
	private static final DateTimeFormatter primaryDateTimeFormatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
	// if user omits year, we assume they mean the current year 
	// to implement this, we append the current year to what the user entered, and so we need another formatter
	private static final DateTimeFormatter secondaryDateTimeFormatter = DateTimeFormatter.ofPattern("dd-MM HH:mm yyyy");
	// the maximum number of args for command types that take in arguments
	// the max arguments for add command varies depending on the form used, so it is not listed here
	private static final int MAX_ARG_REMOVE = 1;
	private static final int MAX_ARG_DONE = 1;
	
	// the size of the list of arguments for adding various types of tasks
	private static final int ADD_ARG_SIZE_FOR_UNSCHEDULED = 1; // only name argument for unscheduled
	private static final int ADD_ARG_SIZE_FOR_DEADLINE = 4; // name, by keyword, date and time = 4
	private static final int ADD_ARG_SIZE_FOR_EVENT = 7; // name, to, from, and 2 date and times
	
	// positions in the parameter list for the add command
	private static final int POSITION_ADD_NAME = 0;
	private static final int POSITION_ADD_FROM_KEYWORD = 1;
	private static final int POSITION_ADD_BY_KEYWORD = 1;
	private static final int POSITION_ADD_TO_KEYWORD = POSITION_ADD_BY_KEYWORD+3;
	
	// positions in the parameter list for the update command
	private static final int POSITION_UPDATE_INDEX = 0;
	
	// used for the add command to determine what type of task is to be added
	private enum TASK_TYPE {
		UNSCHEDULED, DEADLINE, EVENT, INVALID
	}
	
	private static final String HELP_ADD = "add";
	private static final String HELP_LIST = "list";
	private static final String HELP_REMOVE = "remove";
	private static final String HELP_UPDATE = "update";
	private static final String HELP_DONE = "done";
	private static final String HELP_UNDO = "undo";
	private static final String HELP_MOVE = "move";
	private static final String HELP_CLEAR = "clear";
	private static final String HELP_INVALID = "invalid";

	private static final Logger log = Logger.getLogger(Ui.LOG_NAME);
	
	/**
	 * Parse the input into the appropriate command
	 * 
	 * @param input			the input to parse
	 * @return				the command parsed from the input
	 * @throws Exception	if there are an incorrect number of arguments for a given command
	 * 						or if the command is unrecognized
	 */
  public static Command getCommandFromInput(String input) throws Exception {
  	assert(input != null);
  	log.log(Level.INFO, "parsing input \"" + input + "\"\n");
  	// exit early if this is an empty string (which happens when the user types nothing before pressing enter)
  	// this requires special handling because attempting to split this empty string into params causes a size 0 array
  	if (input.equals("")) {
  		log.log(Level.INFO, "aborting parsing because input is an empty string\n");
  		throw new Exception(ERROR_NOTHING_ENTERED);
  	}
  	
  	// also check that if quotes are present, there is a corresponding closing quote. There should be either 0 or 2 quotes, depending on command
  	// this is an important check, because it simplifies parsing for more complex command formats
  	int nQuotes = countQuotesInString(input);
  	if (!(nQuotes == 0 || nQuotes == 2)) {
  		log.log(Level.INFO, "aborting parsing because number of quotes not 0 or 2\n");
  		throw new Exception(ERROR_INVALID_QUOTE_COUNT);
  	}
  	
  	ArrayList<String> params = splitInput(input);
  	log.log(Level.INFO, "params after splitting: " + params + "\n");
  	
  	if (params.size() == 0) {
  		log.log(Level.INFO, "aborting parsing because there are no params\n");
  		throw new Exception(ERROR_NOTHING_ENTERED);
  	}
  	
  	String commandType = getCommandType(params).toLowerCase();
  	ArrayList<String> args = getCommandArgs(params); 
  	
  	switch(commandType) {
    	case "add" :
    		// fall-through
    	case "a":
    		return initAddCommand(args);
    		
    	case "done" :
    		// fall-through
    	case "d":
    		return initDoneCommand(args);
    		
    	case "list" :
    		// fall-through
    	case "l":
    		return initListCommand(args);
    		
    	case "remove" :
    		// fall-through
    	case "r":
    		return initRemoveCommand(args);
    		
    	case "update" :
    		// fall-through
    	case "u":
    		return initUpdateCommand(args);
    		
    	case "undo" :
    		return initUndoCommand();
    		
    	case "help" :
    		// fall-through
    	case "h":
    		return initHelpCommand(args);
    		
    	case "clear":
    		return initClearCommand();
    		
    	case "move":
    		// fall-through
    	case "m":
    		return initMoveCommand(args);
    		
    	case "exit" :
    		// fall-through
    	case "quit" :
    		return initExitCommand();
    		
    	default :
    		log.log(Level.INFO, "Could not determine command type, " + commandType + " is an unsupported command\n");
    		throw new Exception(String.format(ERROR_INVALID_COMMAND, commandType));
  	}
  }

	private static ArrayList<String> splitInput(String input) {
  	ArrayList<String> params = new ArrayList<String>();
  	Matcher m = splitter.matcher(input);
  	
  	while(m.find()) {
  		String param = m.group(1);
	    params.add(param);
  	}
  	
  	return params;
  }
    
  private static String getCommandType(ArrayList<String> params) {
  	assert(params.size() > 0);
    return params.get(POSITION_COMMAND_TYPE);
  }

  private static ArrayList<String> getCommandArgs(ArrayList<String> params) {
    return new ArrayList<String>(params.subList(POSITION_FIRST_PARAM, params.size()));
  }
    
```
###### CommandParser.java
``` java
  private static Command initExitCommand() {
  	return new Exit();
  }
  
  private static Command initAddCommand(ArrayList<String> args) throws Exception {
	  if (args.size() == 0) {
		  log.log(Level.INFO, "Insufficient arguments for add");
		  throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_ADD);
	  }
	  
		Task newTask;
		String name = args.get(POSITION_ADD_NAME); // name is always present in the same position for all tasks
		log.log(Level.INFO, "Name entered = " + name + "\n");
			verifyTaskNameValidity(name);
			name = name.replace("\"", "").trim();
			log.log(Level.INFO, "Name verified\n");
		LocalDateTime endTime, startTime;
		
		switch(determineTaskTypeToBeAdded(args)) {
			case UNSCHEDULED :
				newTask = new Task(name, false);
				log.log(Level.INFO, "created unscheduled task with name " + name + "\n");
				break;
				
			case DEADLINE :
				// the date and time occurs as 2 words, concat them to be parsed
				String deadline = args.get(POSITION_ADD_BY_KEYWORD+1).concat(" ");
				deadline = deadline.concat(args.get(POSITION_ADD_BY_KEYWORD+2));
				endTime = parseDateTime(deadline);
				
					newTask = new Task(name, endTime, false);
					log.log(Level.INFO, "creating deadline with name " + name + " , end date" + endTime + "\n");
				break;
				
			case EVENT :
				// the date and time occurs as 2 words, concat them to be parsed
				String start = args.get(POSITION_ADD_FROM_KEYWORD+1).concat(" ");
				start = start.concat(args.get(POSITION_ADD_FROM_KEYWORD+2));
				String end = args.get(POSITION_ADD_TO_KEYWORD+1).concat(" ");
				end = end.concat(args.get(POSITION_ADD_TO_KEYWORD+2));
				startTime = parseDateTime(start);
				endTime = parseDateTime(end);
				
				newTask = new Task(name, startTime, endTime, false);
				log.log(Level.INFO, "creating event with name " + name + " , start = " + startTime + ", end = " + endTime + "\n");
				break;
				
			default :
				log.log(Level.INFO, "Aborting, cannot determine the type of task to add\n");
				throw new Exception(ERROR_COULD_NOT_DETERMINE_TASK_TYPE_TO_ADD);
		}
		
		return new Add(newTask);
  }
    
  private static Command initUndoCommand() {
  	return new Undo();
  }
  
```
###### CommandParser.java
``` java
  private static Command initMoveCommand(ArrayList<String> args) throws Exception {
	  if (args.size() == 0) {
		  log.log(Level.INFO, "aborting as no folder path was specified.\n");
		  throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_MOVE);
	  }
	  
  	String fileLocation = args.get(0);
  	log.log(Level.INFO, "folder path entered = " + fileLocation + "\n");
  	
  	char first = fileLocation.charAt(0), last = fileLocation.charAt(fileLocation.length()-1);
  	if (first != '"' || last != '"') {
  		log.log(Level.INFO, "aborting as folder path is not in quotes\n");
  		throw new Exception(ERROR_FOLDER_PATH_SHOULD_BE_IN_QUOTES);
  	}
  	
  	String fileLocationWithoutQuotes = fileLocation.substring(1, fileLocation.length() - 1);
  	// it is safe to use slash (but not backslash) in folder paths for java, so replace any backslashes
  	fileLocationWithoutQuotes = fileLocationWithoutQuotes.replace("\\", "/");
  	char end = fileLocationWithoutQuotes.charAt(fileLocationWithoutQuotes.length()-1);

  	if (end != '/') {
  		fileLocationWithoutQuotes = fileLocationWithoutQuotes + "/";
  		log.log(Level.INFO, "appending slash to the end of file location, location = " + fileLocationWithoutQuotes + "\n");
		}
  	  	
  	return new Move(fileLocationWithoutQuotes);
  }

  private static TASK_TYPE determineTaskTypeToBeAdded(ArrayList<String> args) {
  	switch(args.size()) {
    	case ADD_ARG_SIZE_FOR_UNSCHEDULED:
    		return TASK_TYPE.UNSCHEDULED;
    		
    	case ADD_ARG_SIZE_FOR_DEADLINE:
    		boolean isByPresent = args.get(POSITION_ADD_BY_KEYWORD).toLowerCase().equals("by");
    			return isByPresent ? TASK_TYPE.DEADLINE : TASK_TYPE.INVALID;
    		
    	case ADD_ARG_SIZE_FOR_EVENT:
    		boolean isFromPresent = args.get(POSITION_ADD_FROM_KEYWORD).toLowerCase().equals("from");
    		boolean isToPresent= args.get(POSITION_ADD_TO_KEYWORD).toLowerCase().equals("to");
    		return (isFromPresent && isToPresent) ? TASK_TYPE.EVENT : TASK_TYPE.INVALID;
    					
    	default :
    		return TASK_TYPE.INVALID;
  	}
  }
  
```
###### CommandParser.java
``` java
  /*
   *Parses the given string into a LocalDateTime based on the primary or secondary formatter strings
   *An exception is thrown if there was an error parsing the String 
   */
  public static LocalDateTime parseDateTime(String dateTimeString) throws Exception {
  	try {
    	LocalDateTime dateTime = LocalDateTime.parse(dateTimeString, primaryDateTimeFormatter);
    	return dateTime;
  	}
  	catch(DateTimeParseException e) {
  		// deliberately do nothing and try using another formatter
  	}
  	
  	// if the user has the year omited, assume that it is the current year, and try using secondary formatter
  	try {
  		int currentYear = Calendar.getInstance ().get(Calendar.YEAR);
  		LocalDateTime dateTime = LocalDateTime.parse(dateTimeString + " " + currentYear, secondaryDateTimeFormatter);
  		return dateTime;
  	}
    	catch(DateTimeParseException e) {
    		log.log(Level.INFO, "aborting, could not parse " + dateTimeString + " with the given formatter\n");
    		throw new Exception(String.format(ERROR_INVALID_DATE_AND_TIME, dateTimeString));	
  	}
  	
  }
    
  /*
   * Converts the integer represented by this String into an integer
   *An exception is thrown if a parsing error error was encountered 
   */
  private static int parseInt(String integerString) throws Exception {
	  try {
	  return Integer.parseInt(integerString);
	  } catch (NumberFormatException e) {
		  log.log(Level.INFO, "Aborting, could not parse " + integerString + " as an integer\n");
	  		throw new Exception(ERROR_NUMBER_FORMAT);
  }
  }
  
  private static Command initRemoveCommand(ArrayList<String> args) throws Exception {
  	if (args.size() == 0) {
  		log.log(Level.INFO, "aborting, insufficient arguments\n");
  		throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_REMOVE);
  	}
  	
  		if (args.size() > MAX_ARG_REMOVE) {
  			log.log(Level.INFO, "aborting, too many arguments\n");
    	throw new Exception(String.format(ERROR_EXPECTED_ONE_TASK_NUM, "remove"));    		
  	}
  
    	return new Remove(parseInt(args.get(0)));
  }

  private static Command initDoneCommand(ArrayList<String> args) throws Exception {
  	if (args.size() == 0) {
  		log.log(Level.INFO, "aborting, insufficient arguments\n");
  		throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_DONE);
  	}
  			
  			if (args.size() > MAX_ARG_DONE) {
  		  		log.log(Level.INFO, "aborting, too many arguments\n");
    	throw new Exception(String.format(ERROR_EXPECTED_ONE_TASK_NUM, "mark as completed"));    		
  	}
  	
  		int taskNum = parseInt(args.get(0));
    	return new Done(taskNum);
  }
    
  private static Command initUpdateCommand(ArrayList<String> args) throws Exception {
	  boolean isSufficientArguments = args.size() >= 2;
	  if (isSufficientArguments == false) {
	  		log.log(Level.INFO, "aborting, insufficient arguments\n");
	  		throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE);
	  	}
	  	
  	int taskNumToBeUpdated = parseInt(args.get(POSITION_UPDATE_INDEX));
  		DeltaTask changes = getRequestedChanges(args);
  	return new Update(taskNumToBeUpdated, changes);
  }
    
  private static DeltaTask getRequestedChanges(ArrayList<String> params) throws Exception {
  	String newName = null; 
  	LocalDateTime newStart = null, newEnd = null;
  	// boolean flags to prevent multiple modifications of the same field in 1 update command
  	boolean isNameParsed = false, isStartParsed = false, isEndParsed = false; 
  	
  	DeltaTask.FIELD_ACTION nameAction = DeltaTask.FIELD_ACTION.NONE;
  	DeltaTask.FIELD_ACTION startAction = DeltaTask.FIELD_ACTION.NONE;
  	DeltaTask.FIELD_ACTION endAction = DeltaTask.FIELD_ACTION.NONE;
  	
  	for (int i = POSITION_UPDATE_INDEX + 1; i < params.size(); ) {
  		String arg = params.get(i).toLowerCase();
  		switch(arg) {
    		case "+name" :
    			if (isNameParsed == false && (i + 1) < params.size()) {
    		  		log.log(Level.INFO, "+name detected\n");
    				isNameParsed = true;
    				newName = params.get(i + 1);
    				verifyTaskNameValidity(newName);
    				newName = newName.replace("\"", "").trim();
    				nameAction = DeltaTask.FIELD_ACTION.UPDATE;
    				i += 2; // skip over the new name we just added
    			} else {
    		  		log.log(Level.INFO, "aborting " + String.format(ERROR_INVALID_FIELD_TO_UPDATE, "name", arg) + "\n");
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_UPDATE, "name", arg));
    			}
    			break;
    			
    		case "+end" :
    			if (isEndParsed == false && (i + 2) < params.size()) {
    				log.log(Level.INFO, "+end detected\n");
    				isEndParsed = true;
    				String date = params.get(i + 1);
    				String time = params.get(i + 2);
    				newEnd = parseDateTime(date + " " + time);
    				endAction = DeltaTask.FIELD_ACTION.UPDATE;
    				i += 3; // skip past 2 words, which is the new date and time 
    			} else {
    				log.log(Level.INFO, "aborting, " + String.format(ERROR_INVALID_FIELD_TO_UPDATE, "date and time", arg) + "\n");
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_UPDATE, "date and time", arg));
    			}
    			break;
  			
    		case "-end" :
    			if (isEndParsed == false) {
    				log.log(Level.INFO, "-end detected\n");
    				endAction = DeltaTask.FIELD_ACTION.REMOVE;
    				isEndParsed = true;
    				i++;
    			} else {
    				log.log(Level.INFO, "aborting, " + String.format(ERROR_INVALID_FIELD_TO_REMOVE, "end date") + "\n");
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_REMOVE, "end date"));
    			}
    			break;
    			
    		case "+start" :
    			if (isStartParsed == false && (i + 2) < params.size()) {
    				log.log(Level.INFO, "+start detected\n");
    				isStartParsed = true;
    				String date = params.get(i + 1);
    				String time = params.get(i + 2);
    				newStart = parseDateTime(date + " " + time);
    				startAction = DeltaTask.FIELD_ACTION.UPDATE;
    				i += 3; // skip past 2 words, which is the new date and time
    			} else {
    				log.log(Level.INFO, "aborting, " + String.format(ERROR_INVALID_FIELD_TO_UPDATE, "date and time", arg) + "\n");
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_UPDATE, "date and time", arg));
    			}
    			break;
  			
    		case "-start" :
    			if (isStartParsed == false) {
    				log.log(Level.INFO, "+start detected\n");
    				startAction = DeltaTask.FIELD_ACTION.REMOVE;
    				isStartParsed = true;
    				i++;
    			} else {
    				log.log(Level.INFO, "aborting, " + String.format(ERROR_INVALID_FIELD_TO_REMOVE, "start date") + "\n");
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_REMOVE, "start date"));
    			}
    			break;
    		
  			default :
  				log.log(Level.INFO, "aborting, " + arg + " is an unrecognized keyword\n");
  				throw new Exception(String.format(ERROR_UNRECOGNIZED_UPDATE_TOKEN, arg));
    	}
  	}
  	
  	return new DeltaTask(nameAction, newName, startAction, newStart, endAction, newEnd);
  }
    
  private static int countQuotesInString(String input) {
  	int quoteCount = 0;
  	for (int i = 0; i < input.length(); i++) {
  		if (input.charAt(i) == '"') {
  			quoteCount++;
  		}
  	}
  	
  	return quoteCount;
  }
  
  /*
   *Verifies if a task name is valid
   *A valid name must have at least 1 non-whitespace character, and must be surrounded by quotes
   */
  private static void verifyTaskNameValidity(String name) throws Exception {
	  char first = name.charAt(0), last = name.charAt(name.length()-1);
	  
if (name.length() <= 2 || first != '"' || last != '"') {
	log.log(Level.INFO, "aborting, " + name + " is invalid as it is not in quotes\n");
throw new Exception(ERROR_NAME_SHOULD_BE_IN_QUOTES );	
}

String nameWithQuotesRemoved = name.substring(1, name.length()-1);
if (nameWithQuotesRemoved.trim().length() == 0) {
	log.log(Level.INFO, "aborting, " + name + " is invalid as it has no non-whitespace chars\n");
	throw new Exception(ERROR_NAME_SHOULD_CONTAIN_NON_WHITESPACE_CHARS);
}
  }
  
}

```
###### CommandParserTest.java
``` java
public class CommandParserTest {
	
	@Test
	public void testUnsupportedCommandParsing() {
		try {
			CommandParser.getCommandFromInput("abc");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_COMMAND, "abc"));
		}
	}

	@Test
	public void testListCommandParsing() throws Exception {
			Command valid = CommandParser.getCommandFromInput("list");
			assertEquals(List.class, valid.getClass());
	}
	
	@Test
	public void testExitCommandParsing() throws Exception {
			Command valid1 = CommandParser.getCommandFromInput("exit");
			assertEquals(Exit.class, valid1.getClass());
			Command valid2 = CommandParser.getCommandFromInput("Quit");
			assertEquals(Exit.class, valid2.getClass());
	}
	
	@Test
	public void testParsingOfEmptyString() {
		try {
			CommandParser.getCommandFromInput("");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NOTHING_ENTERED);	
		}
		
		try {
			CommandParser.getCommandFromInput("\"\"");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NOTHING_ENTERED);	
		}
		
	}
	
	@Test
	public void testAddUnscheduledTaskCommandParsing() throws Exception {
		
		try {
			CommandParser.getCommandFromInput("add ");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_ADD);
		}
		
		String newTaskName = "read To Kill a Mockingbird";
		
		// task names should be quoted
		try {
			CommandParser.getCommandFromInput("add " + newTaskName);
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NAME_SHOULD_BE_IN_QUOTES);
		}
	
			Command valid1 = CommandParser.getCommandFromInput("add \"" + newTaskName + "\"");
			assertEquals(new Add(new Task(newTaskName, false)), valid1);
		
		try {
			CommandParser.getCommandFromInput("add \" \"");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NAME_SHOULD_CONTAIN_NON_WHITESPACE_CHARS);
		}
			
	}

	@Test
	public void testAddShortcutParsing() throws Exception {
		String newTaskName = "read To Kill a Mockingbird";
		Command valid1 = CommandParser.getCommandFromInput("a \"" + newTaskName + "\"");
		assertEquals(new Add(new Task(newTaskName, false)), valid1);
	}
	
	@Test
	public void testAddDeadlineTaskCommandParsing() throws Exception {
		String newTaskName = "read Harry Potter by J K Rowling";
		// boundary case heuristic: the word to being present in the title should not cause parsing problems
		String validDeadlineString = "21-12-2015 14:40";
		LocalDateTime validDeadline = CommandParser.parseDateTime(validDeadlineString);
		String invalidDeadlineString = "21-13-2015 14:40";
	
			Add valid1 = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" by " + validDeadlineString);
			assertEquals(valid1.getTask().getEndDateTime(), validDeadline);
			assertEquals(new Add(new Task(newTaskName, validDeadline, false)), valid1);
		
		try {
			CommandParser.getCommandFromInput("add \"" + newTaskName + "\" by " + invalidDeadlineString);
			fail("exception not thrown");
		} catch (Exception e) {
		assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_DATE_AND_TIME, invalidDeadlineString));
		}

		try {
			CommandParser.getCommandFromInput("add \"" + newTaskName + "\" by ");
			fail("exception not thrown");
		} catch (Exception e) {
		assertEquals(e.getMessage(), CommandParser.ERROR_COULD_NOT_DETERMINE_TASK_TYPE_TO_ADD);
		}
	}
	
	@Test
	public void testAddEventTaskCommandParsing() throws Exception {
		String newTaskName = "return books borrowed from Ben to him";
		// boundary case heuristic: the word from and to being present in the title should not cause parsing problems
		String validStartString = "21-02-2015 14:40";
		LocalDateTime validStartTime = CommandParser.parseDateTime(validStartString);
		String validEndString = "21-02-2015 15:00";
		LocalDateTime validEndTime = CommandParser.parseDateTime(validEndString);
		String invalidEndString = "21-13-2015 14:40";
	
			Add valid1 = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" from " + validStartString + " to " + validEndString);
			assertEquals(new Add(new Task(newTaskName, validStartTime, validEndTime, false)), valid1);
	  
	  try {
			CommandParser.getCommandFromInput("add \"" + newTaskName + "\" from " + validStartString + " to " + invalidEndString);
			fail("exception not thrown");
	  } catch (Exception e) {
  		assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_DATE_AND_TIME, invalidEndString));
    }
	}
	  
	@Test
	public void testRemoveTaskCommandParsing() throws Exception {
		try {
			CommandParser.getCommandFromInput("remove ");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_REMOVE);
		}
		
		try {
			CommandParser.getCommandFromInput("remove thisIsNotAnInteger");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NUMBER_FORMAT);
		}
		
		try {
			CommandParser.getCommandFromInput("remove 1 2");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_EXPECTED_ONE_TASK_NUM, "remove"));
		}
	
			Command valid1 = CommandParser.getCommandFromInput("remove 1");
			assertEquals(valid1, new Remove(1));
		
	}

	@Test
	public void testRemoveShortcutParsing() throws Exception {
		Command valid1 = CommandParser.getCommandFromInput("r 1");
		assertEquals(valid1, new Remove(1));
	}
	
	@Test
	public void testUpdateCommandParsing() throws Exception {
		try {
			CommandParser.getCommandFromInput("update");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE);
		}
		
		try {
			CommandParser.getCommandFromInput("update 1");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE);
		}
	
		try {
			CommandParser.getCommandFromInput("update thisIsNotAnInteger -end");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NUMBER_FORMAT);
		}
		
		// boundary case heuristic: the word from and to being present in the title should not cause parsing problems
		String newName = "return books borrowed from Ben to him";
		
		String validStartString = "21-02-2015 14:40";
		LocalDateTime validStartTime = CommandParser.parseDateTime(validStartString);
		String validEndString = "21-02-2015 15:00";
		LocalDateTime validEndTime = CommandParser.parseDateTime(validEndString);

		String invalidEndString = "21-13-2015 14:40";
		// declare local constants to avoid fully qualified FIELD_ACTION enum constants, is there a java equivalent of c++'s using keyword?
		DeltaTask.FIELD_ACTION NONE = DeltaTask.FIELD_ACTION.NONE, UPDATE = DeltaTask.FIELD_ACTION.UPDATE, REMOVE = DeltaTask.FIELD_ACTION.REMOVE;
			Update valid1 = (Update)CommandParser.getCommandFromInput("update 1 +name \"" + newName + "\"");
			// If the associated action for a field is NONE, then its new value set in DeltaTask is unimportant as it will never be used 
			assertEquals(valid1.getChanges(), new DeltaTask(UPDATE, newName, NONE, null, NONE, null));

						Update valid2 = (Update)CommandParser.getCommandFromInput("update 1 +end " + validEndString);
						assertEquals(valid2.getChanges(), new DeltaTask(NONE, null, NONE, null, UPDATE, validEndTime));
						
					try {
			CommandParser.getCommandFromInput("update 1 +end " + invalidEndString);
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_DATE_AND_TIME, invalidEndString));
		}
		
		try {
			CommandParser.getCommandFromInput("update 1 +end");
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_FIELD_TO_UPDATE, "date and time", "+end"));
		}

		try {
			CommandParser.getCommandFromInput("update 1 +start");
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_FIELD_TO_UPDATE, "date and time", "+start"));
		}

		try {
			CommandParser.getCommandFromInput("update 1 +name");
			fail();
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_FIELD_TO_UPDATE, "name", "+name"));
		}
		
			Update valid3 = (Update)CommandParser.getCommandFromInput("update 1 +start " + validStartString);
			assertEquals(valid3.getChanges(), new DeltaTask(NONE, null, UPDATE, validStartTime, NONE, null));

			Update valid4 = (Update)CommandParser.getCommandFromInput("update 1 +name \"" + newName + "\" +start " + validStartString + " +end " + validEndString);
			assertEquals(valid4.getChanges(), new DeltaTask(UPDATE, newName, UPDATE, validStartTime, UPDATE, validEndTime));
			
			Update valid5 = (Update)CommandParser.getCommandFromInput("update 1 -end ");
			assertEquals(valid5.getChanges(), new DeltaTask(NONE, null, NONE, null, REMOVE, null));
			

			Update valid6 = (Update)CommandParser.getCommandFromInput("update 1 -start");
			assertEquals(valid6.getChanges(), new DeltaTask(NONE, null, REMOVE, null, NONE, null));
			
		try {
			CommandParser.getCommandFromInput("update 1 -name");
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_UNRECOGNIZED_UPDATE_TOKEN, "-name"));
		}
		
			Update valid7 = (Update)CommandParser.getCommandFromInput("update 1 -start -end");
			assertEquals(valid7.getChanges(), new DeltaTask(NONE, null, REMOVE, null, REMOVE, null));
	}

	@Test
	public void testUpdateShortcutParsing() throws Exception {
		// declare local constants to avoid fully qualified FIELD_ACTION enum constants, is there a java equivalent of c++'s using keyword?
				DeltaTask.FIELD_ACTION NONE = DeltaTask.FIELD_ACTION.NONE, REMOVE = DeltaTask.FIELD_ACTION.REMOVE;
		Update valid1 = (Update)CommandParser.getCommandFromInput("u 1 -start");
		assertEquals(valid1.getChanges(), new DeltaTask(NONE, null, REMOVE, null, NONE, null));
	}
	
	@Test
	public void testDoneParsing() throws Exception {
		try {
			CommandParser.getCommandFromInput("done 1 2");
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_EXPECTED_ONE_TASK_NUM, "mark as completed"));
		}
		
		try {
			CommandParser.getCommandFromInput("done");
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_DONE);
		}
	
			Done valid = (Done)CommandParser.getCommandFromInput("done 1");
			assertEquals(valid, new Done(1));
		
	}
	
	@Test
	public void testDoneShortcutParsing() throws Exception {
		Done valid = (Done)CommandParser.getCommandFromInput("d 1");
		assertEquals(valid, new Done(1));
	}
	
	@Test
	public void testUndoParsing() throws Exception {
			Undo valid = (Undo)CommandParser.getCommandFromInput("undo");
			assertEquals(valid, new Undo());
	}

	@Test
	public void testMoveParsing() throws Exception {
		try {
			CommandParser.getCommandFromInput("move");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_MOVE);
		}
		
		String folderPath = "d:/my documents/dropbox/"; 
			Move valid1 = (Move)CommandParser.getCommandFromInput("move \"" + folderPath + "\"");
			assertEquals(valid1, new Move(folderPath));
		
		// test if backslashes automatically get converted into slashes
			String folderPathUsingBackslashes = folderPath.replace("/", "\\");
		Move valid2 = (Move)CommandParser.getCommandFromInput("move \"" + folderPathUsingBackslashes + "\"");
		assertEquals(valid2, new Move(folderPath));

		try {
			CommandParser.getCommandFromInput("move " + folderPath);
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_FOLDER_PATH_SHOULD_BE_IN_QUOTES);
		}

	}
	
	@Test
	public void testMoveShortcutParsing() throws Exception {
		String folderPath = "d:/my documents/dropbox/";
		Move valid1 = (Move)CommandParser.getCommandFromInput("m \"" + folderPath + "\"");
		assertEquals(valid1, new Move(folderPath));
	}
	
}
```
###### DeltaTask.java
``` java
import java.time.LocalDateTime;

/*
 *This class stores info about what changes users want to make to an existing task
 *Used by CommandParser to communicate with the Update command class.  
 *@author Dickson
 */

public class DeltaTask {
	private String name;
	private LocalDateTime start, end;
	
	// null cannot be used to indicate the absence of changes, because we must differentiate between 
	// the user making no change, or wanting to delete information in that field
	public enum FIELD_ACTION {
		NONE, UPDATE, REMOVE
	}
	
	private FIELD_ACTION nameAction, startAction, endAction;
	
	public DeltaTask(FIELD_ACTION nAction, String newName, FIELD_ACTION sAction, LocalDateTime newStart, FIELD_ACTION eAction, LocalDateTime newEnd) {
		nameAction = nAction;
		startAction = sAction;
		endAction = eAction;
		name = newName;
		start = newStart;
		end = newEnd;
	}
	
	public FIELD_ACTION getNameAction() {
		return nameAction;
	}
	
	public FIELD_ACTION getStartAction() {
		return startAction;
	}
	
	public FIELD_ACTION getEndAction() {
		return endAction;
	}
	
	public String getNewName() {
		return name;
	}
	
	public LocalDateTime getNewStart() {
		return start;
	}
	
	public LocalDateTime getNewEnd() {
		return end;
	}

	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		DeltaTask other = (DeltaTask)obj;
boolean isNameEqual = (name == null && other.getNewName() == null) || (name != null && name.equals(other.getNewName()));
boolean isStartEqual = (start == null && other.getNewStart() == null) || (start != null && start.equals(other.getNewStart()));
boolean isEndEqual = (end == null && other.getNewEnd() == null) || (end != null && end.equals(other.getNewEnd()));

return nameAction == other.getNameAction() && endAction == other.getEndAction() && startAction == other.getStartAction() && isNameEqual && isEndEqual && isStartEqual;
	}
}
```
###### Done.java
``` java
import java.util.ArrayList;

/**
 * Done command to mark a Task as complete. 
 * @author Dickson
 *
 */

public class Done extends Command implements Undoable {
	private static final String SUCCESS_DONE = "\"%s\" is now marked completed.";
	private static final String SUCCESS_DONE_UNDO = "\"%s\" is now marked as uncompleted.";
	private static final String ERROR_INDEX_INVALID = "The task number specified is not valid.";
	private boolean isExecuted;
	private Task completedTask;
	private int taskIndex; // 0-based indexing
	
	public Done(int taskNum) {
		this.isExecuted = false;
		completedTask = null;
		taskIndex = taskNum - 1;
	}
	
	@Override
	/**
	 * Calls the necessary methods to mark a task as completed
	 */
	public void execute() throws Exception {
		completedTask = getTaskFromList();
		storageManager.removeTask(completedTask);
		completedTask.setDone(true);
		storageManager.writeTask(completedTask);
		isExecuted = true;
	}

	private Task getTaskFromList() throws Exception {
		ArrayList<Task> taskList = Ui.getCurrentTaskList();
		if (taskIndex >= 0 && taskIndex < taskList.size()) {
			return taskList.get(taskIndex);
		} else {
			throw new Exception(ERROR_INDEX_INVALID);
		}
		
	}
	
	@Override
	public void undo() throws Exception {
		storageManager.removeTask(completedTask);
		completedTask.setDone(false);
		storageManager.writeTask(completedTask);
	}

	@Override
	public String getSuccessMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_DONE, completedTask.getName());
	}
	
	public Task getTask() {
		return completedTask;
	}
	
	public boolean isExecuted() {
		return isExecuted;
	}
	
	public int getTaskIndex() {
		return taskIndex;
	}
	
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Done other = (Done)obj;		

		boolean isTaskEqual = (completedTask == null && other.getTask() == null) || (completedTask != null && completedTask.equals(other.getTask()));
		
		return isTaskEqual && isExecuted == other.isExecuted() && taskIndex == other.getTaskIndex();
				}

	@Override
	public String getUndoMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_DONE_UNDO, completedTask.getName());
	}
}
```
###### Logic.java
``` java
	public void init(StorageManager sm, Logic logic) throws Exception {
		assert(sm != null);
		storageManager = sm;
		storageManager.openStorage();
		Command.setStorageManager(sm);
		
		assert(logic != null);
		commandLogic = logic;
		Command.setLogic(commandLogic);
	}
		
	public void close() throws Exception {
		storageManager.closeStorage();
	}
		
```
###### Logic.java
``` java
	/*
	 * Determines if the specified task already exists. This is used to prevent 
	 * adding or updating which would cause duplicate tasks
	 */
	public boolean doesTaskExist(Task task) {
		assert(task != null);
		ArrayList<Task> taskList = storageManager.readAllTasks();
		
		for (Task t : taskList) {
			if (t.equals(task)) {
				return true;
			}
		}
		
		return false;
	}
}
```
###### Move.java
``` java
	public String getNewLocation() {
		return newLocation;
	}
	
	public String getOldLocation() {
		return oldLocation;
	}
	
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Move other = (Move)obj;
		boolean isOldLocationEqual = (oldLocation == null && other.getOldLocation() == null) || (oldLocation != null && oldLocation.equals(other.getOldLocation()));
		return isOldLocationEqual && newLocation.equals(other.getNewLocation()); 		
	}
	
	public void undo() throws Exception {
		File oldPath = new File(oldLocation);
		if (oldPath.isDirectory() == false) {
  		log.log(Level.INFO, "aborting because the old folder path is invalid\n");
  		throw new Exception("Undo failed. " + String.format(ERROR_INVALID_FOLDER_PATH, oldLocation));
  	}
		storageManager.changeStorageLocation(oldLocation);
	}
	
	public String getUndoMessage() {
		return String.format(SUCCESS_UNDO, oldLocation);
	}
}
```
###### Remove.java
``` java
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Remove other = (Remove)obj;
		boolean isTaskEqual = (task == null && other.getTask() == null) || (task != null && task.equals(other.getTask()));
		
		return isTaskEqual && isExecuted == other.isExecuted() && index == other.getTaskIndex();
		}
	
		public Task getTask() {
		return this.task;
	}

	public int getTaskIndex() {
		return index;
	}
	
	public boolean isExecuted() {
		return isExecuted;
	}
	
	@Override
	public String getUndoMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_REMOVE_UNDO, task.getName());
	}
}
```
###### Task.java
``` java
import java.time.LocalDateTime;

/**
 * Task is a class that contains all the required information for Command to
 * understand the task.
 */
public class Task implements Comparable<Task> {
	private String name;
	private LocalDateTime start = null;
	private LocalDateTime end = null;
boolean isDone; // used to mark tasks as complete

	public Task(String name, boolean isDone) {
		this(name, null, null, isDone);
	}
	
	public Task(String name, LocalDateTime end, boolean isDone) {
		this(name, null, end, isDone);
	}
	
	public Task(String name, LocalDateTime start, LocalDateTime end, boolean isDone) {
		assert(name != null); // all tasks must have at least a name
		this.name = name;
		this.start = start;
		this.end = end;
		this.isDone = isDone;
	}
	    
	public String getName() {
		return name;
	}
	  
	public LocalDateTime getStartDateTime() {
		return this.start;
	}
	  
	public LocalDateTime getEndDateTime() {
		return this.end;
	} 
	
	public boolean isDone() {
		return isDone;
	}

	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Task other = (Task)obj;
		LocalDateTime otherStart = other.getStartDateTime();
		LocalDateTime otherEnd = other.getEndDateTime();
		boolean isNameEqual = this.getName().equals(other.getName());
				boolean isStartEqual = (start == null && start == otherStart) || (start != null && start.equals(otherStart));
				boolean isEndEqual = (end == null && end == otherEnd) || (end != null && end.equals(otherEnd));
		
		return isNameEqual && isEndEqual && isStartEqual;
	}
	
```
###### Ui.java
``` java
	/*
	 *Converts the information in Task to a String more suitable for printing.  
	 *This is not for UI's column task list display, but is for providing confirmation for commands like add and undo
	 */
	public static String getPrintableTaskString(Task task) {
		String taskName = task.getName();
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		String message = null;;
		
		if (start != null && end != null) {
			message = String.format(MESSAGE_FEEDBACK_EVENT, taskName, getDateTimeFormat(start), getDateTimeFormat(end));
		} else if (start == null && end != null) {
			message = String.format(MESSAGE_FEEDBACK_DEADLINE, taskName, getDateTimeFormat(end));
		} else {
			message = String.format(MESSAGE_FEEDBACK_UNSCHEDULED, taskName);
		}
		return message;
	}

```
###### Undo.java
``` java
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Undo other = (Undo)obj;
		boolean isCommandEqual = false;
		
		if ((lastExecuted == null && other.getLastExecutedCommand() == null) || 
				(lastExecuted != null && lastExecuted.equals(other.getLastExecutedCommand()))) {
			isCommandEqual = true;
		}
		
		return isCommandEqual && wasExecuted == other.isExecuted();
	}
}
```
###### Update.java
``` java
	public Update(int taskNumber, DeltaTask changes) {
		this.oldTask = null;
		this.newTask = null;
		this.changes = changes;
		this.taskIndex = taskNumber - 1;
		this.wasExecuted = false;
	}

	@Override
	/**
	 * Update the task.
	 */
	public void execute() throws Exception {
		ArrayList<Task> taskList = Ui.getCurrentTaskList();
		
		if (taskIndex < 0 || taskIndex >= taskList.size()) {
			log.log(Level.INFO, "aborting, the task index " + taskIndex + " is invalid\n");
			throw new Exception(ERROR_INDEX_INVALID);
		}
	
			oldTask = taskList.get(taskIndex);
			createUpdatedTask();
			// validateDates() will throw an exception if the dates are not valid
			logic.validateDates(newTask.getStartDateTime(), newTask.getEndDateTime());
			
			if (oldTask.equals(newTask)) {
				log.log(Level.INFO, "aborting, the new task resulting from requested changes and the old task are identical\n");
				throw new Exception(ERROR_CHANGES_DO_NOT_RESULT_IN_DIFFERENT_TASK);
			}
			
			if (logic.doesTaskExist(newTask)) {
				log.log(Level.INFO, "aborting, the new task already exists\n");
				throw new Exception(ERROR_TASK_ALREADY_EXISTS);
			}
			
			storageManager.updateTask(oldTask, newTask);
		wasExecuted = true;
	}

	private void createUpdatedTask() throws Exception {
		String newName = null;
		
		switch(changes.getNameAction()) {
			case UPDATE :
				newName = changes.getNewName();
				break;
				
			case NONE :
				newName = oldTask.getName();
				break;
				
			case REMOVE :
				// command parser should not allow name's action to be initialized to REMOVE
				log.log(Level.WARNING, "aborting, the nameAction field was initialized to remove by commandParser, which should be impossible\n");
				assert("A request to remove task name slipped through command parser's "
						+ "defences, execution should not reach here" == null);
		}
		
		assert(newName != null);
		
		// for requests to remove non-existent fields, like removing the start date 
		// of a unscheduled task, forgive and ignore the error
		LocalDateTime newStart = null;
		switch(changes.getStartAction()) {
			case UPDATE :
				newStart = changes.getNewStart();
				break;
				
			case NONE :
				newStart = oldTask.getStartDateTime();
				break;
				
			case REMOVE :
				newStart = null;
		}
	
		LocalDateTime newEnd = null;
		switch(changes.getEndAction()) {
			case UPDATE :
				newEnd = changes.getNewEnd();
				break;
				
			case NONE :
				newEnd = oldTask.getEndDateTime();
				break;
				
			case REMOVE :
				newEnd = null;
		}
	
		
		if (isTaskParametersValid(newName, newStart, newEnd) == false) {
			log.log(Level.INFO, "aborting, the new task is invalid as it has a start date but no end date\n");
			throw new Exception(ERROR_UPDATED_TASK_IS_INVALID);
		}
		
		newTask = new Task(newName, newStart, newEnd, oldTask.isDone());
	}
	
	private static boolean isTaskParametersValid(String name, LocalDateTime start, LocalDateTime end) {
		assert(name != null);
		return !(start != null && end == null);
	}
	
```
###### Update.java
``` java
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Update other = (Update)obj;
		boolean isOldTaskEqual = (oldTask == null && other.getOldTask() == null) || (oldTask != null && oldTask.equals(other.getOldTask()));
		boolean isNewTaskEqual = (newTask == null && other.getNewTask() == null) || (newTask != null && newTask.equals(other.getNewTask()));
		boolean isChangesEqual = (changes == null && other.getChanges() == null) || (changes != null && oldTask.equals(other.getChanges()));
		
		return isOldTaskEqual && isNewTaskEqual && isChangesEqual && wasExecuted == other.isExecuted() && taskIndex == other.getTaskIndex();
	}
	
	public Task getOldTask() {
		return this.oldTask;
	}
	
	public Task getNewTask() {
		return this.newTask;
	}

	// this is to facilitate unit testing
	public DeltaTask getChanges() {
		return changes;
	}
	
	public boolean isExecuted() {
		return wasExecuted;
	}

	public int getTaskIndex() {
		return taskIndex;
	}
	
	@Override
	public String getUndoMessage() {
		return String.format(SUCCESS_UPDATE_UNDO, newTask.getName(), Ui.getPrintableTaskString(oldTask));
	}
	
	}
```
