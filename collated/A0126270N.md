# A0126270N
###### Command.java
``` java
	public static void setStorageManager(StorageManager sm) {
		assert(sm != null);
		storageManager = sm;
	}
}
```
###### CommandParser.java
``` java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * CommandParser parses user's input to create Command objects that have the
 * appropriate fields initialised. For example, the "remove" command requires the
 * taskName field to be initialised.
 * 
 * @author Dickson
 *
 */

public class CommandParser {
	// error messages for thrown exceptions, public to facilitate testing
	public static final String ERROR_NAME_NOT_IN_QUOTES = "The task name must be enclosed in quotations marks.";
	public static final String ERROR_NOTHING_ENTERED = "Please enter a command.";
	public static final String ERROR_INVALID_QUOTE_COUNT = "There is text inside a quote without a corresponding closing quote, or there are too many quotes.";
	public static final String ERROR_INVALID_COMMAND = "\"%s\" is not a supported command.";
  public static final String ERROR_EXPECTED_ONE_TASK_NUM = "Please indicate only one task to %s.";
  public static final String ERROR_NUMBER_FORMAT = "Please specify a valid task number.";
	public static final String ERROR_INVALID_DATE_AND_TIME = "%s is not a date and time in dd-mm-yyyy hh:mm format.";
	public static final String ERROR_COULD_NOT_DETERMINE_TASK_TYPE_TO_ADD = "The type of task to be added could not be determined.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_ADD = "Please specify the name for the new task, and its start and end date and time if appropriate.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_REMOVE = "Please specify the task number to be removed.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_DONE = "Please specify the task number to be marked completed.";
	public static final String ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE = "Please specify the task to be updated, and fields to be modified or removed.";
	public static final String ERROR_INVALID_FIELD_TO_UPDATE = "A new %s was not found after %s, or you are trying to perform multiple modifications to that field.";
	public static final String ERROR_INVALID_FIELD_TO_REMOVE = "The %s field could not be removed because you are trying to perform multiple modifications to that field.";
	public static final String ERROR_UNRECOGNIZED_UPDATE_TOKEN = "%s is not a valid update token.";
	
	// positions in the command input
	private static final int POSITION_COMMAND_TYPE = 0;
  private static final int POSITION_FIRST_PARAM = 1;
    
  // the regex pattern to split input by spaces, except if there is a quoted string. 
//   E.g read LOTR in the string '"read LOTR" by 21-02-2015 12:00' is 1 token 
  // because of the way tokenizing is done, an argument like date and time which has a space between them is counted as 2 arguments
	private static final Pattern splitter = Pattern.compile("([^\"]\\S*|\".+?\")\\s*");
	
	// the formatter used to parse date and time
	private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
	
	// the maximum number of args for command types that take in arguments
	// the max arguments for add command varies depending on the form used, so it is not listed here
	private static final int MAX_ARG_REMOVE = 1;
	private static final int MAX_ARG_DONE = 1;
	
	// the size of the list of arguments for adding various types of tasks
	private static final int ADD_ARG_SIZE_FOR_UNSCHEDULED = 1; // only name argument for unscheduled
	private static final int ADD_ARG_SIZE_FOR_DEADLINE = 4; // name, by keyword, date and time = 4
	private static final int ADD_ARG_SIZE_FOR_EVENT = 7; // name, to, from, and 2 date and times
	
	// positions in the parameter list for the add command
	private static final int POSITION_ADD_NAME = 0;
	private static final int POSITION_ADD_FROM_KEYWORD = 1;
	private static final int POSITION_ADD_BY_KEYWORD = 1;
	private static final int POSITION_ADD_TO_KEYWORD = POSITION_ADD_BY_KEYWORD+3;
	
	// positions in the parameter list for the update command
	private static final int POSITION_UPDATE_INDEX = 0;
	
	// used for the add command to determine what type of task is to be added
	private enum TASK_TYPE {
		UNSCHEDULED, DEADLINE, EVENT, INVALID
	}
	
	//used for the add command to determine what type of task is to be added
	private static final String HELP_ADD = "add";
	private static final String HELP_REMOVE = "remove";
	private static final String HELP_LIST = "list";
	private static final String HELP_INVALID = "invalid";
	
	/**
	 * Parse the input into the appropriate command
	 * 
	 * @param input			the input to parse
	 * @return				the command parsed from the input
	 * @throws Exception	if there are an incorrect number of arguments for a given command
	 * 						or if the command is unrecognized
	 */
  public static Command getCommandFromInput(String input) throws Exception {
  	assert(input != null);
  	// exit early if this is an empty string (which happens when the user types nothing before pressing enter)
  	// this requires special handling because attempting to split this empty string into params causes a size 0 array
  	if (input.equals("")) {
  		throw new Exception(ERROR_NOTHING_ENTERED);
  	}
  	
  	// also check that if quotes are present, there is a corresponding closing quote. There should be either 0 or 2 quotes, depending on command
  	if (isNumberOfQuotesValid(input) == false){
  		throw new Exception(ERROR_INVALID_QUOTE_COUNT);
  	}
  	
  	ArrayList<String> params = splitInput(input);
  	String commandType = getCommandType(params).toLowerCase();
  	ArrayList<String> args = getCommandArgs(params); 
  	
  	switch(commandType) {
    	case "add" :
    		// fall-through
    	case "a":
    		return initAddCommand(args);
    		
    	case "done" :
    		return initDoneCommand(args);
    		
    	case "list" :
    		// fall-through
    	case "l":
    		return initListCommand(args);
    		
    	case "remove" :
    		// fall-through
    	case "r":
    		return initRemoveCommand(args);
    		
    	case "update" :
    		// fall-through
    	case "u":
    		return initUpdateCommand(args);
    		
    	case "undo" :
    		return initUndoCommand();
    		
    	case "help" :
    		return initHelpCommand(args);
    		
    	case "reformat":
    		return initReformatCommand();
    		
    	case "relocate":
    		return initRelocateCommand(args);
    		
    	case "exit" :
    		// fallthrough
    		
    	case "quit" :
    		return initExitCommand();
    		
    	default :
    		throw new Exception(String.format(ERROR_INVALID_COMMAND, commandType));
  	}
  }

	private static ArrayList<String> splitInput(String input) {
  	ArrayList<String> params = new ArrayList<String>();
  	Matcher m = splitter.matcher(input);
  	
  	while(m.find()) {
  		String param = m.group(1);
	    params.add(param);
  	}
  	
  	return params;
  }
    
  private static String getCommandType(ArrayList<String> params) {
  	assert(params.size() > 0);
    return params.get(POSITION_COMMAND_TYPE);
  }

  private static ArrayList<String> getCommandArgs(ArrayList<String> params) {
    return new ArrayList<String>(params.subList(POSITION_FIRST_PARAM, params.size()));
  }
    
```
###### CommandParser.java
``` java
  private static Command initExitCommand() {
  	return new Exit();
  }
  
  private static Command initAddCommand(ArrayList<String> args) throws Exception {
	  if (args.size() == 0) {
		  throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_ADD);
	  }
	  
		Task newTask;
		String name = "";
	
			name = args.get(POSITION_ADD_NAME); // name is always present in the same position for all tasks
			if (!name.startsWith("\"")) {
				throw new Exception(ERROR_NAME_NOT_IN_QUOTES);
			}
	  		name = name.replace("\"", "");
		
		LocalDateTime endTime, startTime;
		
		switch(determineTaskTypeToBeAdded(args)) {
			case UNSCHEDULED :
				newTask = new Task(name, false);
				break;
				
			case DEADLINE :
				// the date and time occurs as 2 words, concat them to be parsed
				String deadline = args.get(POSITION_ADD_BY_KEYWORD+1).concat(" ");
				deadline = deadline.concat(args.get(POSITION_ADD_BY_KEYWORD+2));
				endTime = parseDateTime(deadline);
				
					newTask = new Task(name, endTime, false);
				break;
				
			case EVENT :
				// the date and time occurs as 2 words, concat them to be parsed
				String start = args.get(POSITION_ADD_FROM_KEYWORD+1).concat(" ");
				start = start.concat(args.get(POSITION_ADD_FROM_KEYWORD+2));
				String end = args.get(POSITION_ADD_TO_KEYWORD+1).concat(" ");
				end = end.concat(args.get(POSITION_ADD_TO_KEYWORD+2));
				startTime = parseDateTime(start);
				endTime = parseDateTime(end);
				
				newTask = new Task(name, startTime, endTime, false);
				break;
				
			default :
				throw new Exception(ERROR_COULD_NOT_DETERMINE_TASK_TYPE_TO_ADD);
		}
		
		return new Add(newTask);
  }
    
  private static Command initUndoCommand() {
  	return new Undo();
  }
  
  private static Command initHelpCommand(ArrayList<String> args) throws Exception {
  	String helpType;
  	
  	if (args.size() == 0) {
			return new Help();
		} else {
			
			helpType = determineHelpTypeToBeList(args);
					
			if (helpType != HELP_INVALID) {
				return new Help(determineHelpTypeToBeList(args));
			} else {
				throw new Exception("The type of help to be shown could not be determined.");
			}
		}
  }
  
  private static Command initReformatCommand() {
  	return new Reformat();
  }
  
  private static Command initRelocateCommand(ArrayList<String> args) {
  	String fileLocation = args.get(0);
  	
  	fileLocation = fileLocation.substring(1, fileLocation.length() - 1);
  	
  	return new Relocate(fileLocation);
  }

  private static TASK_TYPE determineTaskTypeToBeAdded(ArrayList<String> args) {
  	switch(args.size()) {
    	case ADD_ARG_SIZE_FOR_UNSCHEDULED:
    		return TASK_TYPE.UNSCHEDULED;
    		
    	case ADD_ARG_SIZE_FOR_DEADLINE:
    		boolean isByPresent = args.get(POSITION_ADD_BY_KEYWORD).toLowerCase().equals("by");
    			return isByPresent ? TASK_TYPE.DEADLINE : TASK_TYPE.INVALID;
    		
    	case ADD_ARG_SIZE_FOR_EVENT:
    		boolean isFromPresent = args.get(POSITION_ADD_FROM_KEYWORD).toLowerCase().equals("from");
    		boolean isToPresent= args.get(POSITION_ADD_TO_KEYWORD).toLowerCase().equals("to");
    		return (isFromPresent && isToPresent) ? TASK_TYPE.EVENT : TASK_TYPE.INVALID;
    					
    	default :
    		return TASK_TYPE.INVALID;
  	}
  }
  
  private static String determineHelpTypeToBeList(ArrayList<String> args) {	
  	switch (args.get(0).toLowerCase()) {
  		case HELP_ADD:
  				return HELP_ADD;
  		case HELP_LIST:
				return HELP_LIST;
  		case HELP_REMOVE:
				return HELP_REMOVE;
  		default :
  			return HELP_INVALID;
  	}
  }
    
  /*
   *Parses the given string into a LocalDateTime based on the dateAndTimeFormatter string
   *An exception is thrown if there was an error parsing the String 
   */
  public static LocalDateTime parseDateTime(String dateTimeString) throws Exception {
  	try {
    	LocalDateTime dateTime = LocalDateTime.parse(dateTimeString, dateTimeFormatter);
    	return dateTime;
  	} 
    	catch(DateTimeParseException e) {
    		throw new Exception(String.format(ERROR_INVALID_DATE_AND_TIME, dateTimeString));	
  	}
  	
  }
    
  /*
   * Converts the integer represented by this String into an int
   *An exception is thrown if a parsing error error was encountered 
   */
  private static int parseInt(String integerString) throws Exception {
	  try {
	  return Integer.parseInt(integerString);
	  } catch (NumberFormatException e) {
	  		throw new Exception(ERROR_NUMBER_FORMAT);
  }
  }
  
  private static Command initRemoveCommand(ArrayList<String> args) throws Exception {
  	if (args.size() == 0) {
  		throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_REMOVE);
  	}
  	
  		if (args.size() > MAX_ARG_REMOVE) {
    	throw new Exception(String.format(ERROR_EXPECTED_ONE_TASK_NUM, "remove"));    		
  	}
  
    	return new Remove(parseInt(args.get(0)));
  }

  private static Command initDoneCommand(ArrayList<String> args) throws Exception {
  	if (args.size() == 0) {
  		throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_DONE);
  	}
  			
  			if (args.size() > MAX_ARG_DONE) {
    	throw new Exception(String.format(ERROR_EXPECTED_ONE_TASK_NUM, "mark as completed"));    		
  	}
  	
  		int taskNum = parseInt(args.get(0));
    	return new Done(taskNum);
  }
    
  private static Command initUpdateCommand(ArrayList<String> args) throws Exception {
	  boolean isSufficientArguments = args.size() >= 2;
	  if (isSufficientArguments == false) {
	  		throw new Exception(ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE);
	  	}
	  	
  	int taskNumToBeUpdated = parseInt(args.get(POSITION_UPDATE_INDEX));
  		DeltaTask changes = getRequestedChanges(args);
  	return new Update(taskNumToBeUpdated, changes);
  }
    
  private static DeltaTask getRequestedChanges(ArrayList<String> params) throws Exception {
  	String newName = null; 
  	LocalDateTime newStart = null, newEnd = null;
  	// boolean flags to prevent multiple modifications of the same field in 1 update command
  	boolean isNameParsed = false, isStartParsed = false, isEndParsed = false; 
  	
  	DeltaTask.FIELD_ACTION nameAction = DeltaTask.FIELD_ACTION.NONE;
  	DeltaTask.FIELD_ACTION startAction = DeltaTask.FIELD_ACTION.NONE;
  	DeltaTask.FIELD_ACTION endAction = DeltaTask.FIELD_ACTION.NONE;
  	
  	for (int i = POSITION_UPDATE_INDEX + 1; i < params.size(); ) {
  		String arg = params.get(i).toLowerCase();
  		switch(arg) {
    		case "+name" :
    			if (isNameParsed == false && (i + 1) < params.size()) {
    				isNameParsed = true;
    				newName = params.get(i + 1);
    				if (!newName.startsWith("\"")) {
    					throw new Exception(ERROR_NAME_NOT_IN_QUOTES);
    				}
    		  		newName = newName.replace("\"", "");
    				nameAction = DeltaTask.FIELD_ACTION.UPDATE;
    				i += 2; // skip over the new name we just added
    			} else {
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_UPDATE, "name", arg));
    			}
    			break;
    			
    		case "+end" :
    			if (isEndParsed == false && (i + 2) < params.size()) {
    				isEndParsed = true;
    				String date = params.get(i + 1);
    				String time = params.get(i + 2);
    				newEnd = parseDateTime(date + " " + time);
    				endAction = DeltaTask.FIELD_ACTION.UPDATE;
    				i += 3; // skip past 2 words, which is the new date and time 
    			} else {
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_UPDATE, "date and time", arg));
    			}
    			break;
  			
    		case "-end" :
    			if (isEndParsed == false) {
    				endAction = DeltaTask.FIELD_ACTION.REMOVE;
    				isEndParsed = true;
    				i++;
    			} else {
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_REMOVE, "end date"));
    			}
    			break;
    			
    		case "+start" :
    			if (isStartParsed == false && (i + 2) < params.size()) {
    				isStartParsed = true;
    				String date = params.get(i + 1);
    				String time = params.get(i + 2);
    				newStart = parseDateTime(date + " " + time);
    				startAction = DeltaTask.FIELD_ACTION.UPDATE;
    				i += 3; // skip past 2 words, which is the new date and time
    			} else {
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_UPDATE, "date and time", arg));
    			}
    			break;
  			
    		case "-start" :
    			if (isStartParsed == false) {
    				startAction = DeltaTask.FIELD_ACTION.REMOVE;
    				isStartParsed = true;
    				i++;
    			} else {
    				throw new Exception(String.format(ERROR_INVALID_FIELD_TO_REMOVE, "start date"));
    			}
    			break;
    		
  			default :
  				throw new Exception(String.format(ERROR_UNRECOGNIZED_UPDATE_TOKEN, arg));
    	}
  	}
  	
  	return new DeltaTask(nameAction, newName, startAction, newStart, endAction, newEnd);
  }
    
  private static boolean isNumberOfQuotesValid(String input) {
  	int quoteCount = 0;
  	for (int i = 0; i < input.length(); i++) {
  		if (input.charAt(i) == '"') {
  			quoteCount++;
  		}
  	}
  	
  	return quoteCount == 0 || quoteCount == 2;
  }
}

```
###### CommandParserTest.java
``` java
public class CommandParserTest {
	
	private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
	
@Test
	public void testUnsupportedCommandParsing() {
	try {
		Command invalid = CommandParser.getCommandFromInput("abc");
	} catch(Exception e) {
		assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_COMMAND, "abc"));
	}
	}

	@Test
	public void testListCommandParsing() {
		Command c;
		try {
			c = CommandParser.getCommandFromInput("list");
			assertEquals(List.class, c.getClass());
		} catch (Exception e) {
			fail();
		}
	}
	
	@Test
	public void testExitCommandParsing() {
		Command c1;
		try {
			c1 = CommandParser.getCommandFromInput("exit");
			assertEquals(Exit.class, c1.getClass());
			Command c2 = CommandParser.getCommandFromInput("Quit");
			assertEquals(Exit.class, c2.getClass());
		} catch (Exception e) {
			fail("exception was thrown");
		}
	}
	
	@Test
	public void testParsingOfEmptyString() {
		try {
			// boundary case: nothing is typed before the user presses enter
			Command invalid = CommandParser.getCommandFromInput("");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NOTHING_ENTERED);	
		}
		
	}
	
	@Test
	public void testAddUnscheduledTaskCommandParsing() {
		try {
			// boundary case: the only thing entered is the command name with no trailing spaces and further arguments
			Command invalid = CommandParser.getCommandFromInput("add ");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_ADD);
		}
		
		String newTaskName = "read To Kill a Mockingbird";
		// Multi-word task names should invalid; task names with more than 1 word must be quoted
		try {
			// this should throw an exception
			Command invalid2 = CommandParser.getCommandFromInput("add " + newTaskName);
			fail();
		} catch (Exception e) {
			
		}
		
		try {
			Command valid = CommandParser.getCommandFromInput("add \"" + newTaskName + "\"");
			assertEquals(new Add(new Task(newTaskName, false)), valid);
		} catch (Exception e) {
			fail("exception thrown");
		}
		
			
	}

	@Test
	public void testAddDeadlineTaskCommandParsing() throws Exception {
		String newTaskName = "read Harry Potter by J K Rowling";
		// boundary case heuristic: the word to being present in the title should not cause parsing problems
		String validDeadlineString = "21-12-2015 14:40";
		LocalDateTime validDeadline = CommandParser.parseDateTime(validDeadlineString);
		String invalidDeadlineString = "21-13-2015 14:40";
		
try {
			Add validCommand = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" by " + validDeadlineString);
			assertEquals(validCommand.getTask().getEndDateTime(), validDeadline);
			assertEquals(new Add(new Task(newTaskName, validDeadline, false)), validCommand);
} catch (Exception e) {
	fail("exception thrown");
}

try {
			Add invalidCommand = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" by " + invalidDeadlineString);
			fail("exception not thrown");
} catch (Exception e) {
assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_DATE_AND_TIME, invalidDeadlineString));
}

try {
	// boundary case: the "by" keyword is present without any date
	Add invalidCommand = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" by ");
	fail("exception not thrown");
} catch (Exception e) {
assertEquals(e.getMessage(), CommandParser.ERROR_COULD_NOT_DETERMINE_TASK_TYPE_TO_ADD);
}

	}
	
		@Test
    	public void testAddEventTaskCommandParsing() throws Exception {
    		String newTaskName = "return books borrowed from Ben to him";
    		// boundary case heuristic: the word from and to being present in the title should not cause parsing problems
    		String validStartString = "21-02-2015 14:40";
    		LocalDateTime validStartTime = CommandParser.parseDateTime(validStartString);
    		String validEndString = "21-02-2015 15:00";
    		LocalDateTime validEndTime = CommandParser.parseDateTime(validEndString);
    		String invalidEndString = "21-13-2015 14:40";
    		
    try {
    			Add validCommand = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" from " + validStartString + " to " + validEndString);
    			assertEquals(new Add(new Task(newTaskName, validStartTime, validEndTime, false)), validCommand);
    } catch (Exception e) {
    	fail("exception thrown");
    }

    try {
    			Add invalidCommand = (Add) CommandParser.getCommandFromInput("add \"" + newTaskName + "\" from " + validStartString + " to " + invalidEndString);
    			fail("exception not thrown");
    } catch (Exception e) {
assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_DATE_AND_TIME, invalidEndString));
    }
    		
    	}
    
	@Test
	public void testRemoveTaskCommandParsing() {
		try {
			Command invalid = CommandParser.getCommandFromInput("remove ");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_REMOVE);
		}
		
		try {
			Command invalid = CommandParser.getCommandFromInput("remove thisIsNotAnInteger");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NUMBER_FORMAT);
		}
		
		try {
			Command invalid = CommandParser.getCommandFromInput("remove 1 2");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_EXPECTED_ONE_TASK_NUM, "remove"));
		}
		
		try {
			Command valid = CommandParser.getCommandFromInput("remove 1");
			assertEquals(new Remove(1), valid);
		} catch (Exception e) {
			fail("exception thrown");
		}
		
	}

	@Test
	public void testUpdateCommandParsing() throws Exception {
		try {
		Command invalid = CommandParser.getCommandFromInput("update");
		fail("exception not thrown");
	} catch (Exception e) {
		assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE);
	}
		
		try {
		Command invalid = CommandParser.getCommandFromInput("update 1");
		fail("exception not thrown");
	} catch (Exception e) {
		assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_UPDATE);
	}
	
		try {
			Command invalid = CommandParser.getCommandFromInput("update thisIsNotAnInteger -end");
			fail("exception not thrown");
		} catch (Exception e) {
			assertEquals(e.getMessage(), CommandParser.ERROR_NUMBER_FORMAT);
		}
		
		// boundary case heuristic: the word from and to being present in the title should not cause parsing problems
		String newName = "return books borrowed from Ben to him";
		
		String validStartString = "21-02-2015 14:40";
		LocalDateTime validStartTime = CommandParser.parseDateTime(validStartString);
		String validEndString = "21-02-2015 15:00";
		LocalDateTime validEndTime = CommandParser.parseDateTime(validEndString);

		String invalidEndString = "21-13-2015 14:40";
	
		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 +name \"" + newName + "\"");
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(nameAction, DeltaTask.FIELD_ACTION.UPDATE);
			assertEquals(changes.getNewName(), newName);
		} catch(Exception e) {
			fail("exception thrown");
		}
		
		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 +end " + validEndString);
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.UPDATE);
			assertEquals(nameAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(changes.getNewEnd(), validEndTime);
		} catch(Exception e) {
			fail("exception thrown");
		}

		try {
			Update invalid = (Update)CommandParser.getCommandFromInput("update 1 +end " + invalidEndString);
			fail("exception not thrown");
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_DATE_AND_TIME, invalidEndString));
		}
		
		try {
			Update invalid = (Update)CommandParser.getCommandFromInput("update 1 +end");
fail();
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_FIELD_TO_UPDATE, "date and time", "+end"));
		}

		try {
			Update invalid = (Update)CommandParser.getCommandFromInput("update 1 +start");
fail();
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_FIELD_TO_UPDATE, "date and time", "+start"));
		}

		try {
			Update invalid = (Update)CommandParser.getCommandFromInput("update 1 +name");
fail();
		} catch(Exception e) {
			assertEquals(e.getMessage(), String.format(CommandParser.ERROR_INVALID_FIELD_TO_UPDATE, "name", "+name"));
		}

		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 +start " + validStartString);
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.UPDATE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(nameAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(changes.getNewStart(), validStartTime);
		} catch(Exception e) {
			fail();
		}
		
		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 +name \"" + newName + "\" +start " + validStartString + " +end " + validEndString);
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.UPDATE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.UPDATE);
			assertEquals(nameAction, DeltaTask.FIELD_ACTION.UPDATE);
			assertEquals(changes.getNewStart(), validStartTime);
			assertEquals(changes.getNewEnd(), validEndTime);
			assertEquals(changes.getNewName(), newName);
		} catch(Exception e) {
			fail("Exception thrown");
		}
		
		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 -end ");
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.REMOVE);
			assertEquals(nameAction, DeltaTask.FIELD_ACTION.NONE);
		} catch(Exception e) {
			fail("exception thrown");
		}
		
		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 -start");
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.REMOVE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.NONE);
			assertEquals(nameAction, DeltaTask.FIELD_ACTION.NONE);
		} catch(Exception e) {
			fail("exception thrown");
		}
		
		try {
			Update invalid = (Update)CommandParser.getCommandFromInput("update 1 -name");
		fail();
		} catch(Exception e) {
assertEquals(e.getMessage(), String.format(CommandParser.ERROR_UNRECOGNIZED_UPDATE_TOKEN, "-name"));
		}
		
		try {
			Update valid = (Update)CommandParser.getCommandFromInput("update 1 -start -end");
			DeltaTask changes = valid.getChanges();
			DeltaTask.FIELD_ACTION startAction = changes.getStartAction(), endAction = changes.getEndAction(), nameAction = changes.getNameAction();
			assertEquals(startAction, DeltaTask.FIELD_ACTION.REMOVE);
			assertEquals(endAction, DeltaTask.FIELD_ACTION.REMOVE);
		} catch(Exception e) {
			fail("exception thrown");
		}
		
	}

	@Test
	public void testDoneParsing() {
		try {
			Command invalid = CommandParser.getCommandFromInput("done 1 2");
			fail("exception not thrown");
		} catch(Exception e) {
				assertEquals(e.getMessage(), String.format(CommandParser.ERROR_EXPECTED_ONE_TASK_NUM, "mark as completed"));
			}
		
		try {
			Command invalid = CommandParser.getCommandFromInput("done");
			fail("exception not thrown");
		} catch(Exception e) {
				assertEquals(e.getMessage(), CommandParser.ERROR_INSUFFICIENT_ARGUMENTS_FOR_DONE);
			}
		
		try {
			Done valid = (Done)CommandParser.getCommandFromInput("done 1");
			assertEquals(valid, new Done(1));
		} catch(Exception e) {
			fail("exception thrown");
			}
	}
	
		@Test
		public void testUndoParsing() {
			try {
				Undo valid = (Undo)CommandParser.getCommandFromInput("undo");
				assertEquals(valid, new Undo());
			} catch (Exception e) {
				fail("exception thrown");
			}
		}
	
}
```
###### DeltaTask.java
``` java
import java.time.LocalDateTime;

/*
 *This class stores info about what changes users want to make to an existing task
 *Used by CommandParser to communicate with the Update command class.  
 *@author Dickson
 */

public class DeltaTask {
	private String name;
	private LocalDateTime start, end;
	
	// null cannot be used to indicate the absence of changes, because we must differentiate between 
	// the user making no change, or wanting to delete information in that field
	public enum FIELD_ACTION {
		NONE, UPDATE, REMOVE
	}
	
	private FIELD_ACTION nameAction, startAction, endAction;
	
	public DeltaTask(FIELD_ACTION nAction, String newName, FIELD_ACTION sAction, LocalDateTime newStart, FIELD_ACTION eAction, LocalDateTime newEnd) {
		nameAction = nAction;
		startAction = sAction;
		endAction = eAction;
		name = newName;
		start = newStart;
		end = newEnd;
	}
	
	public FIELD_ACTION getNameAction() {
		return nameAction;
	}
	
	public FIELD_ACTION getStartAction() {
		return startAction;
	}
	
	public FIELD_ACTION getEndAction() {
		return endAction;
	}
	
	public String getNewName() {
		return name;
	}
	
	public LocalDateTime getNewStart() {
		return start;
	}
	
	public LocalDateTime getNewEnd() {
		return end;
	}

	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		DeltaTask other = (DeltaTask)obj;
boolean isNameEqual = (name == null && other.getNewName() == null) || (name != null && name.equals(other.getNewName()));
boolean isStartEqual = (start == null && other.getNewStart() == null) || (start != null && start.equals(other.getNewStart()));
boolean isEndEqual = (end == null && other.getNewEnd() == null) || (end != null && end.equals(other.getNewEnd()));

return nameAction == other.getNameAction() && endAction == other.getEndAction() && startAction == other.getStartAction() && isNameEqual && isEndEqual && isStartEqual;
	}
}
```
###### Done.java
``` java
import java.util.ArrayList;

/**
 * Done command to mark a Task as complete. 
 * @author Dickson
 *
 */

public class Done extends Command implements Undoable {
	private static final String SUCCESS_DONE = "\"%s\" is now marked completed.";
	private static final String SUCCESS_DONE_UNDO = "\"%s\" is now marked as uncompleted.";
	private static final String ERROR_INDEX_INVALID = "The task number specified is not valid.";
	private boolean isExecuted;
	private Task completedTask;
	private int taskIndex; // 0-based indexing
	
	public Done(int taskNum) {
		this.isExecuted = false;
		completedTask = null;
		taskIndex = taskNum - 1;
	}
	
	@Override
	/**
	 * Calls the necessary methods to mark a task as completed
	 */
	public void execute() throws Exception {
		completedTask = getTaskFromList();
		storageManager.removeTask(completedTask);
		completedTask.setDone(true);
		storageManager.writeTask(completedTask);
		isExecuted = true;
	}

	private Task getTaskFromList() throws Exception {
		ArrayList<Task> taskList = Ui.getCurrentTaskList();
		if (taskIndex >= 0 && taskIndex < taskList.size()) {
			return taskList.get(taskIndex);
		} else {
			throw new Exception(ERROR_INDEX_INVALID);
		}
		
	}
	
	@Override
	public void undo() throws Exception {
		storageManager.removeTask(completedTask);
		completedTask.setDone(false);
		storageManager.writeTask(completedTask);
	}

	@Override
	public String getSuccessMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_DONE, completedTask.getName());
	}
	
	public Task getTask() {
		return completedTask;
	}
	
	public boolean isExecuted() {
		return isExecuted;
	}
	
	public int getTaskIndex() {
		return taskIndex;
	}
	
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Done other = (Done)obj;		

		boolean isTaskEqual = (completedTask == null && other.getTask() == null) || (completedTask != null && completedTask.equals(other.getTask()));
		
		return isTaskEqual && isExecuted == other.isExecuted() && taskIndex == other.getTaskIndex();
				}

	@Override
	public String getUndoMessage() {
		assert(isExecuted);
		return String.format(SUCCESS_DONE_UNDO, completedTask.getName());
	}
}
```
###### Logic.java
``` java
		public static void init(StorageManager sm) {
			assert(sm != null);
			storageManager = sm;
			storageManager.openStorage();
			Command.setStorageManager(sm);
		}
		
		public static void close() {
			storageManager.closeStorage();
		}
		
```
###### Task.java
``` java
import java.time.LocalDateTime;

/**
 * Task is a class that contains all the required information for Command to
 * understand the task.
 */
public class Task implements Comparable<Task> {
	private String name;
	private LocalDateTime start = null;
	private LocalDateTime end = null;
boolean isDone; // used to mark tasks as complete

	public Task(String name, boolean isDone) {
		this(name, null, null, isDone);
	}
	
	public Task(String name, LocalDateTime end, boolean isDone) {
		this(name, null, end, isDone);
	}
	
	public Task(String name, LocalDateTime start, LocalDateTime end, boolean isDone) {
		assert(name != null); // all tasks must have at least a name
		this.name = name;
		this.start = start;
		this.end = end;
		this.isDone = isDone;
	}
	    
	public String getName() {
		return name;
	}
	  
	public LocalDateTime getStartDateTime() {
		return this.start;
	}
	  
	public LocalDateTime getEndDateTime() {
		return this.end;
	} 
	
	public boolean isDone() {
		return isDone;
	}

	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Task other = (Task)obj;
		LocalDateTime otherStart = other.getStartDateTime();
		LocalDateTime otherEnd = other.getEndDateTime();
		boolean isNameEqual = this.getName().equals(other.getName());
				boolean isStartEqual = (start == null && start == otherStart) || (start != null && start.equals(otherStart));
				boolean isEndEqual = (end == null && end == otherEnd) || (end != null && end.equals(otherEnd));
		
		return isNameEqual && isEndEqual && isStartEqual;
	}
	
```
###### Ui.java
``` java
	/*
	 *Converts the information in Task to a String more suitable for printing.  
	 *This is not for UI's column task list display, but is for providing confirmation for commands like add and undo
	 */
	public static String getPrintableTaskString(Task task) {
		String str = "\"" + task.getName() + "\"";
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		
		if (start != null && end != null) {
			str += ", scheduled from " + getDateTimeFormat(start) + " to " + getDateTimeFormat(end);
		} else if (start == null && end != null) {
			str += ", due by " + getDateTimeFormat(end);
		}
		
		return str;
	}

```
###### Undo.java
``` java
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Undo other = (Undo)obj;
		boolean isCommandEqual = false;
		
		if ((lastExecuted == null && other.getLastExecutedCommand() == null) || 
				(lastExecuted != null && lastExecuted.equals(other.getLastExecutedCommand()))) {
			isCommandEqual = true;
		}
		
		return isCommandEqual && wasExecuted == other.isExecuted();
	}
}
```
###### Update.java
``` java
	public Update(int taskNumber, DeltaTask changes) {
		this.oldTask = null;
		this.newTask = null;
		this.changes = changes;
		this.taskIndex = taskNumber - 1;
		this.wasExecuted = false;
	}

```
###### Update.java
``` java
	private void createUpdatedTask() throws Exception {
		String newName = null;
		
		switch(changes.getNameAction()) {
			case UPDATE :
				newName = changes.getNewName();
				break;
				
			case NONE :
				newName = oldTask.getName();
				break;
				
			case REMOVE :
				// command parser should not allow name's action to be initialized to REMOVE
				assert("A request to remove task name slipped through command parser's "
						+ "defences, execution should not reach here" == null);
		}
		
		assert(newName != null);
		
		// for requests to remove non-existent fields, like removing the start date 
		// off a unscheduled task, forgive and ignore the error
		LocalDateTime newStart = null;
		switch(changes.getStartAction()) {
			case UPDATE :
				newStart = changes.getNewStart();
				break;
				
			case NONE :
				newStart = oldTask.getStartDateTime();
				break;
				
			case REMOVE :
				newStart = null;
		}
	
		LocalDateTime newEnd = null;
		switch(changes.getEndAction()) {
			case UPDATE :
				newEnd = changes.getNewEnd();
				break;
				
			case NONE :
				newEnd = oldTask.getEndDateTime();
				break;
				
			case REMOVE :
				newEnd = null;
		}
	
		
		if (isTaskParametersValid(newName, newStart, newEnd) == false) {
			throw new Exception(ERROR_UPDATED_TASK_IS_INVALID);
		}
		
		newTask = new Task(newName, newStart, newEnd, oldTask.isDone());
	}
	
	private static boolean isTaskParametersValid(String name, LocalDateTime start, LocalDateTime end) {
		assert(name != null);
		return !(start != null && end == null);
	}
	
```
###### Update.java
``` java
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != this.getClass()) { 
			return false; 
		}
		
		Update other = (Update)obj;
		boolean isOldTaskEqual = (oldTask == null && other.getOldTask() == null) || (oldTask != null && oldTask.equals(other.getOldTask()));
		boolean isNewTaskEqual = (newTask == null && other.getNewTask() == null) || (newTask != null && newTask.equals(other.getNewTask()));
		boolean isChangesEqual = (changes == null && other.getChanges() == null) || (changes != null && oldTask.equals(other.getChanges()));
		
		return isOldTaskEqual && isNewTaskEqual && isChangesEqual && wasExecuted == other.isExecuted() && taskIndex == other.getTaskIndex();
	}
	
	public Task getOldTask() {
		return this.oldTask;
	}
	
	public Task getNewTask() {
		return this.newTask;
	}

	// this is to facilitate unit testing
	public DeltaTask getChanges() {
		return changes;
	}
	
	public boolean isExecuted() {
		return wasExecuted;
	}

	public int getTaskIndex() {
		return taskIndex;
	}
	@Override
	public String getUndoMessage() {
		return String.format(SUCCESS_UPDATE_UNDO, newTask.getName(), Ui.getPrintableTaskString(oldTask));
	}
	
	}
```
